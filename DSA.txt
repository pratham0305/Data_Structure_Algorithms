                       ----------This contains codes of Data Structures written C or C++ ----------------------
                    
  1. Binary search :
  I/P:
#include<iostream>
using namwspace std;
/* It is using iterators.*/

int Binary_Search(struct Array arr,int key){//Here, we have used struct Array and object arr.
	int l=0;
	int h = arr.length-1; //Here, .length is a class function means ut can only be applied on members of structure and classes.
	
	while(l<=h){
		int mid = (l+h)/2;
		
		if(key==arr.A[mid]){
			return mid;
		}else if(key<arr.A[mid]){
			h = mid-1;
			   
		}else{
			l= mid+1;
		}
		

	}
	return -1;
}

int main(){
	struct Array arr={{2,3,5,6},20,23}; //Here, Array is the name of the struct and arr is the name of the object.
	
    cout<<Binary_Search(arr,5); //It will only show the index number if the found element.
	
	return 0;
	
}
 
------------------------------------------------------------------------------
/*Using recursive function.*/ 
int Rbinary_Search(int A[],int l,int h, int key){
	int mid;
	if(l<=h){
		mid = (l+h)/2;
		if(key==A[mid]){
			return mid;
		}else if(key<A[mid]){
			return Rbinary_Search(A,l,mid-1,key)
		}else{
			return Rbinary_Search(A,mid+1,h,key)
		}
	}
	return -1;
}
int main(){
	int A[3]= {1,2,3};
	Rbinary_Search(A,0,2,2);
	return 0;
}
----------------------OPTIMISED BINARY SEARCH---------------------
int BinarySearch(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int mid= start + ((end-start)/2);  //Replaced mid=(s+e)/2  with s+(e-s/2)
    while(start<=end){
        if(arr[mid]==key){
            return mid;
        }
        
        if(key>arr[mid]){
            start=mid+1;
        }else{
            end=mid-1;
        }
        mid=start+((end-start)/2);
    }
    return -1;
-------------------------------------------------------------------

2. Revesing an array :

I/P:   
/*This method uses an another array.
int reverse(int A[]){
  int i,j;
  int B[];
  }
  for(i=A.length-1,j=0;i>=0,j>=A[].length-1;i--,j++){
      B[j] = A[i];
  }
  
  for(i=0,j=0;i>=B.length-1,j>=B.length-1;i++,j++){
      A[i] = B[j];
      }
--------------------------------------------------------------------------------
/*This one uses swapping of the elements within the array.
int main(){
   int i,j;
   for(i=0,j=A.length-1;i>=A.length-1,j=0;i++,j--){
      int temp = A[i];
      A[i] = A[j];
      A[j] = temp;
   }
}

3. Linked List:
#include<iostream>
using namespace std;
class Node{
    public:
        int data;
        Node* next;
        Node(int data){
            this->data=data;
            this->next=NULL;
        }
        ~Node(){
            int value=this->data;
            if(this->next!=NULL){
                delete next;
                this->next=NULL;
            }
        }
};
//This function works when nodes are added sequentially
//write a separate insertAtMiddle() for adding nodes at random places.
void insertNode(int pos,int d,Node* &head){
    //in front of first node
    if(pos==1){
        Node* newNode=new Node(d);
        newNode->next=head;
        head=newNode;
    }else{
        Node* temp=head;
        int cnt=0;
        while(cnt<pos-1){
            temp=temp->next;
            cnt++;

        }//last node insert
        if(temp->next=NULL){
            Node* newNode=new Node(d);
            temp->next=newNode;
            return;
        }//anywhere in between
        Node* newNode=new Node(d);
        newNode->next=temp->next;
        temp->next=newNode;
        
    }
    
}
void deleteNode(int pos,Node* &head){
    if(pos==1){
        Node* temp=head;
        head=head->next;
        temp->next=NULL;
        delete temp;
    }else{
        Node* curr=head;
        Node* prev=NULL;
        int cnt=1;
        while(cnt<pos){
            prev=curr;
            curr=curr->next;
            cnt++;
        }
        //last node
        if(curr->next==NULL){
            prev->next=NULL;
            delete curr;
            return;
        }
        prev->next=curr->next;
        curr->next=NULL;
        delete curr;
    }
}
void print(Node* head){
    Node* temp=head;
    cout<<endl;
    while(temp!=NULL){
        cout<<temp->data<<", ";
        temp=temp->next;
    }
    cout<<endl;
}
int main(){

   

    Node* node1=new Node(134);
    Node* head=node1;
    insertNode(1,34,head);
    insertNode(2,67,head);
    insertNode(3,45,head);
    print(head);
    deleteNode(2,head);
    print(head);
   




    return 0;
}
                         Types of Linked List:
(a) Circular Linked List: In this type of linked list the lat node has the address to the first or head node.In this we can trevers in both the directons.

I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class LinkedList{
	
	private:
		LinkedList(){
			Node *head;
		}
	
	public:
		LinkedList(){
			Node *head =NUll;
		}
		LinkedList(int A[],int n){
			Node *t,*last;
			head= new Node;
			head->data = A[0];
			head->next=head;
			last=head;
			
			for(int i=1;i<n;i++){
				Node *t,*last;
				t=new Node;
				t->data=A[i];
				t->next=last->next;
				last->next=t;
				last=t;
				
				
			}
			
		}
		
		void Display(Node *p){
			Node *p;
			p=head;
			do{
				cout<<p->data;
				p=p->next;
			}while(p!=head);
		}
};
#include<iostream>
using namespace std;

class Node {
	public:
	int data;
	Node *next;
};

int main() {
	//Creating the first node.
	Node *head,*last;
	Node *p = new Node;
	head = p;
	
	cout<<"Enter the first element:";
	cin>>head->data;//taking the vaule of first node.
	head->next = NULL;
	last = head;//Since it is the lone node, kas will also point to it.
	
	int input;
	while(1) {//Creating other nodes.
		cout<<"\nEnter the element or 0 to exit:";
		cin>>input;
		
		if(input == 0) {
			cout<<"\nYou have entered all the elements:";
			break;
			
		}else { 
		
			Node *t = new Node;
			t->data = input;//Taking in the value.
			last->next = t;//Storing the address of this node in the previous one.
			last = t;//last pointer will now point to the end node i.e. the new node.
			last->next = head;//the last pointer will also point to the head node(because this is a circular linked list).
			
		}
	}
	
	p=head;
	do{
		cout<<p->data<<"\t";
		p=p->next;
	}while(p!=head);//Since this is a circular linked list we cannot use the p!=NULL condition.
	
	
	
	
	
	return 0;
}

(b) Doubly Linked List: This is that type type of the linked list where Node contains the address of the previous and the next Node.In this we can only traverse in only one direction.
I/P:
class Node{
   public:
     Node *prev;
     int data;
     Node *next;
};

class LinkedList{
  public:
    LinkedList(int A[],int n){
       Node *t,*last;
       first = new Node;
       first->data=A[0];
       first->prev=first->next=NULL;
       last=first;
       
       for(int i=0;i>n;i++){
          Node *t,*last;
	  t= new Node;
	  t->data = A[i];
	  t->prev=last->next;
	  last->next=t;
	  last =t;
	  
	  
       }
       
  }
  
    void Display(class Node *p){
       p=first;
       while(p!=0){
         cout<<p->data;
	 p=p->next;
       }
    }
  
    
};
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *prev;
		Node *next;
};

int main() {
	//Creating the head node.
	Node *head = new Node;
	Node *last;
	cout<<"Enter the first element:";
	cin>>head->data;
	
	head->prev = NULL;
	head->next = NULL;
	last = head;//head and last pointer will point at the lone node.
	
	//Creating the second node.
	Node *t = new Node;
	cout<<"Enter the element:";
	cin>>t->data;
	head->next = t;
	t->prev = head;
	t->next = NULL;
	last = t;//Now, the second node is the end hence, the last pointer will point to this node.
	
	int answer;
	while(1) {
		Node *p = new Node;//Creating the more nodes.
		cout<<"\nEnter the element or 0 to exit:";
		cin>>answer;
		
		if(answer == 0) {
			
			cout<<"\nYou have entered all the elements.\n";
			break;
			
		} else {
			
			p->data = answer;
			p->next = NULL;//This newly created node is the end node.
			p->prev = last;//It's previous pointer will point to the node created before it.
			last->next = p;//The previous node's next pointer point to the newly created node.
			last = p;//Now,the newly created node is the end node.
			
			
			
		}
		
	}
	//Displaying the list in reverse, just check the previous pointer of nodes works.
	Node *p;
	p=last; //Pointing l to the head node.
	while(p!=NULL) {
		cout<<"\n"<<p->data;
		p=p->prev;
	}
	
	return 0;
}
(d) Doubly Circular Linked List:- 

#include<iostream>
using namespace std;

class Node {
	public:
	int data;
	Node *next;
	Node *prev;
};

int main() {
	//Creating the first node.
	Node *head,*last;
	Node *p = new Node;
	head = p;
	
	cout<<"Enter the first element:";
	cin>>head->data;//taking the vaule of first node.
	head->next = NULL;
	head->prev = NULL;
	last = head;//Since it is the lone node, last will also point to it.
	
	int input;
	while(1) {//Creating other nodes.
		cout<<"\nEnter the element or 0 to exit:";
		cin>>input;
		
		if(input == 0) {
			cout<<"\nYou have entered all the elements:";
			break;
			
		}else { 
		
			Node *t = new Node;
			t->data = input;//Taking in the value.
			last->next = t;
			t->prev = last;
			last = t;
			last->next = head;
			
		}
	}
	//Printing the list in reverse order.
	/*p=last;
	do{
		cout<<p->data<<"\t";
		p=p->prev;
	}while(p!=NULL);*/
	
	//Printing the list in fwd order.
	p=head;
	do{
		cout<<p->data<<"\t";
		p=p->next;
	}while(p!=head);
	
	
	
	
	
	return 0;
}

4. Stack:

#Creating A stack:
I/P:  This code is writtne in c_languge-
#include<iostream>
using namespace std;

struct stack{
	int size;
	int top;  //This is used to traverse thought the stack.
	int *s; // This represnts the stack itself.
};

int main(){
	
	struct stack st;
	
	cout<<"Enter the soze of the stack:";
	cin>>st.size;
	st.s = new int[st.size]; //Stack using an array.
	st.top = -1;
	
	return 0;
}
#Push funcution:
I/P:
void push(stack *st,int x){
	
	if(st->top==st->size-1){
		cout<<"Stack Overflow."
	}else{
		st->top++;  //This command lets us to iterate to the empty sapce of the stack.
	    st->s[st->top]=x;  //We are using '*s' pointer to traverse through and 'top' for accessing the indexes by using object pointer 'st'.
	}
}

#Pop function:
I/P:

int pop(stack *st){
	int x=-1;
	if(st->top==-1){
		cout<<"Stack Overflow";
	}else{
		st->s[st->top]=x;
		st->top--;
	}
	return x;
}

#Peek function:
I/P:
                                    
void peek(struct stack st,int pos){
	
	int x=-1;
	if(st.top - pos +1>0){
		cout<<"Invalid Position";
	}else{
		x=st.s[st.top - pos +1]; //This is a formula for finding out the index of the stack.
	}
	return x;
}

#Diplaying the stack:
I/P:
void Display(struct stack st){
    for(int i=top;i>=0;i--){
       cout<<st->s[i];
    }
}

----------------------------------------------------------------------------------
Stack Using Linked List: In this type we will start inserting elements from the last and to head.
#include<iostream>
using namespace std;

class node{
    public:
        int data;
        node *next;
        node(int data){
            this->data=data;
            this->next=NULL;
        }
};

class stack{

    public:
        node *top;
        stack(){
            top=NULL;
        }
        void push(int e){
            if(top==NULL){
                node *temp=new node(e);
                top=temp;
            }else{
                node *temp=new node(e);
                temp->next=top;
                top=temp;
            }

        }

        void pop(){
            if(top==NULL){
                node *temp=top;
                delete temp;
                top=NULL;
                cout<<"element gone"<<endl;
            }else{
                node *temp=top;
                top=temp->next;
                delete temp;
                cout<<"deleted"<<endl;
            }
        }
        int peek(){
            if(top==NULL){
                cout<<"Stack empty";
                return -1;
            }else{
                return top->data;
            }
        }

        bool isEmpty(){
            if(top==NULL){
                return true;
            }else{
                return false;
            }
        }
        void display(){
            node *temp=top;
            while(temp!=NULL){
                cout<<temp->data<<" ";
                temp=temp->next;
            }
            cout<<endl;
        }

};

int main(){

    stack st;
    st.push(34);
    st.push(45);
    st.push(90);
    st.push(182);
    st.display();
    st.pop();
    cout<<st.peek()<<endl;
    st.pop();
    st.pop();
    st.pop();
    st.pop();
    cout<<st.isEmpty();
    cout<<st.peek();
    
    return 0;
}
Two Stack implementation in using an array:
#include<iostream>
using namespace std;
class TwoStack{
    public:
        int *arr;
        int top1;
        int top2;
        int size;
        TwoStack(int size){
            this->size=size;
            arr=new int[size];
            this->top1=-1;
            this->top2=size;
        }

        void push1(int e){
            if(top2-top1>1){
                top1++;
                arr[top1]=e;
            }else{
                cout<<"Stack overflow"<<endl;
            }

        }

        void push2(int e){
            if(top2-top1>1){
                top2--;
                arr[top2]=e;
            }else{
                cout<<"Stack overflow"<<endl;
            }
        }

        void pop1(){
            if(top1>=0){
                top1--;
            }else{
                cout<<"Stack underflow"<<endl;
            }
        }
        void pop2(){
            if(top2<size){
                top2++;
            }else{
                cout<<"Stack underflow"<<endl;
            }
        }
        int peek1(){
            if(top1>=0){
                return arr[top1];
            }else{
                return -1;
            }
        }

        int peek2(){
            if(top2<size){
                return arr[top2];
            }else{
                return -1;
            }
        }
        void display(){
            cout<<"Stack 1"<<endl;
            int s=top1;
            while(s>-1){
                cout<<arr[s]<<" ";
                s--;
            }
            cout<<endl;
            cout<<"Stack 2"<<endl;
            s=top2;
            while(s<size){
                cout<<arr[s]<<" ";
                s++;
            }
        }
};

int main(){
    TwoStack st(6);
    st.push1(12);
    st.push2(56);
    cout<<st.peek1()<<endl;
    st.push2(23);
    cout<<st.peek2()<<endl;
    st.display();

    return 0;
}

5. Queues :- Follows FIFO property.
# Using an array: 
I/P:
NOTE:- Following codes are written in C language.
struct queue{    //This is how a queue's structure should look like.
	int size;
	int front;
	int rear;
	int *Q;
};


int main(){
	
	struct queue q;    //Initializing a queue.
	cout<<"Enter the size of the queue:";
	cin>>q.size;
	
	q.Q = new queue;
	q.front=q.rear=-1;
	
	return 0;
}

# Enqueue function:
I/P:
void enqueue(queue *q,int x){
	if(q->rear==q->size-1){
		cout<<"Queue is full";
	}else{
		cout<<"Enter the value you want to enter:";
		cin>>x;
		q->rear++;
		q->Q[q->rear]=x;
		
	}
	
	
}
# Dequeue function:
I/P:
int dequeue(queue *q){
   int x=-1;
   if(q->front==q->rear){
      cout<<"Queue is empty";
   }else{
      q->front++;
      x=q->Q[q->rear];
   }
   return x;
}
--------------------------------------------------------
Note: The code written below is written in C++ languge:
#include<iostream>
using namespace std;
//Using array
class Queue{
	public:
		int *arr;
		int qfront;
		int rear;
		int size;

		Queue(){
			this->size=10000;
			arr=new int[size];
			qfront=rear=0;
		}

		void enqueue(int e){
			if(rear==size-1){
				cout<<"Queue is full"<<endl;
			}else{
				arr[rear]=e;
				rear++;
			}
			

		}

		int dequeue(){
			int ans;
			if(rear==qfront){
				cout<<"Queue is empty"<<endl;
			}else{
				ans=arr[qfront];
				arr[qfront]=-1;
				qfront++;
				if(qfront==rear){//partial empty, to avoid wastage of storage
					qfront=rear=0;
				}
			}
			return ans;
		}

		int Front(){
			if(qfront==rear){
				return -1;
			}else{
				return arr[qfront];
			}
		}
		
		void display(){
			for(int i=0;i<size;i++){
				cout<<arr[i]<<" ";
			}
			cout<<endl;
		}
		bool isEmpty(){
			if(rear==qfront){
				return true;
			}else{
				return false;
			}
			
		}

};

int main(){
	Queue Q;
	Q.enqueue(56);
	Q.enqueue(90);
	Q.enqueue(52);
	Q.enqueue(920);
	Q.enqueue(67);
	cout<<Q.Front();

	return 0;
}
Queue implementation using linked list
#include<iostream>
using namespace std;

class qNode{
	public:
		int data;
		qNode* next;
		qNode(int d){
			this->data=d;
			this->next=NULL;
		}
};

class Queue{
	public:
		qNode* front;
		qNode* rear;
		Queue(){
			front=rear=NULL;
		}

		void enqueue(int e){
			qNode* temp=new qNode(e);

			if(rear==NULL){
				front=rear=temp;
			}else{
				rear->next=temp;
				rear=temp;
			}
		}

		void dequeue(){
			if(front==NULL){
				cout<<"Queue is empty"<<endl;
			}else{
				qNode* temp=front;
				front=temp->next;
				if(front==NULL){//if there is only one element
					rear=NULL;
				}
				delete temp;
			}
		}
		void display(){
			qNode* temp=front;

			while(temp!=NULL){
				cout<<temp->data<<" ";
				temp=temp->next;
			}
			cout<<endl;
		}

};

int main(){
	Queue q;
    q.enqueue(10);
    q.enqueue(20);
    q.enqueue(30);
    q.enqueue(40);
    q.enqueue(50);
	cout<<(q.front)->data<<endl;
	cout<<(q.rear)->data<<endl;
	q.display();


	return 0;
}

                  Circular Queue (Differences can be spot in enqueue,dequeue and the display function):

class CircularQueue{
    public:
    // Initialize your data structure.
    int *arr;
    int front;
    int rear;
    int size;
    CircularQueue(int n){
        // Write your code here.
        size=n;
        arr=new int[size];
        front=rear=-1;
    }

    // Enqueues 'X' into the queue. Returns true if it gets pushed into the stack, and false otherwise.
    bool enqueue(int value){
        // To check whether queue is full
        if(front==0 && rear==(size-1)|| rear== (front-1) %(size-1)){
            return false;
        }else if(front==-1){//single elememt to push
            front=rear=0;
            
          
        }else if(rear==size-1 && front!=0){
            //to maintain cyclic nature
            rear=0;
            
        }else{
            rear++;
            
        }
        arr[rear]=value;
        return true;
    }
    

    // Dequeues top element from queue. Returns -1 if the stack is empty, otherwise returns the popped element.
    int dequeue(){
        int ans;
        if(front==-1){//to check if queue is empty
            return -1;
        }
        ans=arr[front];
        arr[front]=-1;
        if(front==rear){//single element is present
            front=rear=-1;
        }else if(front==size-1){
            //to maintian cyclic nature 
            front=0;
        }else{
            front++;
        }
        return ans;
    }
};
-----------------------------
Double Ended Queue:
class Deque
{	
    int *arr;
    int front;
    int rear;
    int size;
public:
    // Initialize your data structure.
    Deque(int n)
    {
        size = n;
        arr = new int[n];
        front = -1;
        rear = -1;
    }

    // Pushes 'X' in the front of the deque. Returns true if it gets pushed into the deque, and false otherwise.
    bool pushFront(int x)
    {
        //check full or not
        if( isFull() ) {
            return false;
        }
        else if(isEmpty()) {
            front  = rear = 0;
        }
        else if(front == 0 && rear != size-1) {
            front = size-1;
        } 
        else
        {
            front--;
        }
        arr[front] = x;
        return true;
    }

    // Pushes 'X' in the back of the deque. Returns true if it gets pushed into the deque, and false otherwise.
    bool pushRear(int x)
    {
        if( isFull() ) {
            return false;
        }
        else if(isEmpty()) {
            front  = rear = 0;
        }
        else if(rear == size-1 && front != 0) {
            rear = 0;
        } 
        else
        {
             rear++;
        }
        arr[rear] = x;
        return true;
    }

    // Pops an element from the front of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
    int popFront()
    {
        if(isEmpty()){//to check queue is empty
            //cout << "Queue is Empty " << endl;
            return -1;
        }
        
        int ans = arr[front];
        arr[front] = -1;
        
        if(front == rear) { //single element is present
            front = rear = -1;
        }
        else if(front == size - 1) {
            front = 0; //to maintain cyclic nature
        }
        else
        {//normal flow
            front++;
        }
        return ans;
    }

    // Pops an element from the back of the deque. Returns -1 if the deque is empty, otherwise returns the popped element.
    int popRear()
    {
         if(isEmpty()){//to check queue is empty
            //cout << "Queue is Empty " << endl;
            return -1;
        }
        
        int ans = arr[rear];
        arr[rear] = -1;
        
        if(front == rear) { //single element is present
            front = rear = -1;
        }
        else if(rear == 0) {
            rear = size-1; //to maintain cyclic nature
        }
        else
        {//normal flow
            rear--;
        }
        return ans;
    }

    // Returns the first element of the deque. If the deque is empty, it returns -1.
    int getFront()
    {
        if(isEmpty()){
            return -1;
        }
        return arr[front];
    }

    // Returns the last element of the deque. If the deque is empty, it returns -1.
    int getRear()
    {
       if(isEmpty()){
            return -1;
        }
        return arr[rear];
    }

    // Returns true if the deque is empty. Otherwise returns false.
    bool isEmpty()
    {
        if(front == -1)
            return true;
        else
            return false;
    }

    // Returns true if the deque is full. Otherwise returns false.
    bool isFull()
    {
		if( (front == 0 && rear == size-1) || (front != 0 && rear == (front-1)%(size-1) ) ) {
            return true;
        }
        else
        {
            return false;
        }
    }
};

6. Trees:-
----------------------------------------------------------------
Binary Tree Using Recursion:
#include<iostream>
using namespace std;

class node {
    public:
        int data;
        node* left;
        node* right;
    node(int d){
        this->data=d;
        this->left=NULL;
        this->right=NULL;
    }    
};

node* buildTree(node *root){
    int data;
    cout<<"Enter data:"<<endl;
    cin>>data;
    root = new node(data);
    if(data==-1){
        return NULL;

    }

    cout<<"Enter data for inserting left of "<<data<<endl;
    root->left=buildTree(root->left);
    cout<<"Enter data for inserting right of"<<data<<endl;
    root->right=buildTree(root->right);
    return root;

    
}

int main(){
    node* root=NULL;
    root=buildTree(root);

    return 0;
}
------------------------------------------------------
Using Linked List-
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		Node *rchild;
};

class Queue{
	private:
		int size;
		int front;
		int rear;
		Node **Q;
		
	public:
		Queue(int size){
			this->size=size;
			front=rear=-1;
			Q = new Node* [size];
		}
		
		~Queue(){
			delete []Q;
		}
		
		bool isEmpty(){
			if(front==rear){
				return true;
			}else{
				return false;
			}
		}
		
		bool isFull(){
			if(rear==size-1){
				return true;
			}else{
				return false;
			}
		}
		
		void enqueue(Node *x){
			if(isFull()){
				cout<<"Queue overflow.";
			}else{
				rear++;
				Q[rear]=x;
			}
			
		}
		
		Node *dequeue(){
			
			Node *x = NULL;
			if(isEmpty()){
				cout<<"Queue is Empty.";
			}else{
				front++;
				x=Q[front];
			}
			return x;
		}
};

Node *root = new Node;

void Treecreate(){
	Node *p;
	Node *t;
	Queue q(10);
	int x;
	cout<<"Enter the root of the tree:";
	cin>>x;
	root->data =x;
	root->lchild = NULL;
	root->rchild=NULL;
	q.enqueue(root);
	while(!q.isEmpty()){
		p=q.dequeue();
		
		cout<<"Enter the value of the left child of  "<<p->data<<":";
		cin>>x;
		if(x!=-1){
			t =new Node;
			t->data=x;
			t->lchild=NULL;
			t->rchild=NULL;
			p->lchild=t;
			q.enqueue(t);
		}
		cout<<"Enter the value of right child of "<<p->data<<":";
		cin>>x;
		if(x!=-1){
			t= new Node;
			t->data=x;
			t->lchild=NULL;
			t->rchild=NULL;
			p->rchild=t;
			q.enqueue(t);
		}
	}
	
	
}

void preorder(Node *p){
	if(p){
		cout<<p->data<<",";
		preorder(p->lchild);
		preorder(p->rchild);
	}
}

void inorder(Node *p){
	if(p){
		inorder(p->lchild);
		cout<<p->data<<",";
		inorder(p->rchild);
	}
}

void postorder(Node *p){
	if(p){
		preorder(p->lchild);
		preorder(p->rchild);
		cout<<p->data<<",";
	}
}

int main(){
	Treecreate();
	preorder(root);
	cout<<endl;
	
}

## Counting number of nodes in a Binary tree:-
I/P:
int count(Node *p){  //This funcntion is used to count the number of nodes in a tree.
    int x,y;
    if(p!=NULL){
       	x=count(p->lchild);
	y=count(p->rchild);
	return x+y+1;
    }
    return 0;
}

int count(Node *p){   //This function will count number of nodes with degree 2 or nodes with two children.
   int x,y;
   if(p!=NULL){
      x=count(p->lchild);
      y=count(p->rchild);
      if(p->lchild && p->rchild){
          return x+y+1;
	  }else{
	     return x+y;
	  }
	  return 0;
   }
}


## Binary Search Tree:-
(a) Searching -
I/P: 
int Rsearch(Node *t,int key){
    cout<<"Enter the key you want to search:";;
    cin>>key;
    if(t==NULL){
      return t;    //This function uses recursive call to search
    }else(
       if(key==t->data){
          reutn t;
       }else if(key>p->data){
          return Rsearch(p->lchild,key);
       }else{
          return Rsearch(p->rchild,key);
       }
    )
}

/* This funcction uses search iteratively.*/
Node *search(Node *t,int key){
   cout<<"Enter the key value you want to search:";
   cin>>key;
   while(t!=NULL){
     if(key==t->data){
        return t;
     }else if(key<t->data){
        t=t->lchild;
     }else{
        t=t->rchild;
     }
     
   }
   return NULL;
   
## Inserting Node in a Binary search tree:
I/P:
void insert(Node *t,int key){
  cout<<"Enter the key you want to insert:";
  cin>>key;
  
  Node *r=NULL;*t;
  while(t!=NULL){
     r=t;
     if(key==t->data){
        return;
     }else if(key<t->data){ 
        t=t->lchild;
     
     }else{
        t=t->rchild;
     }
    }
     Node *p = new Node;
     p->lchild = p->rchild = NULL;
     p->data = key;
     if(p->data<r->data){
        r->lchild = p;
     }else{
        r->rchild = p;
     }
  }
  /* This Insert function is written in recursive form form.
Node *insert(Node *p,int key){
   Node *t;
   if(p=NULL){
      t= new Node;
      t->data =key;
      t->lchild = t->rchild = NULL;
      return t;
   }
   if(key<p->data){
     p->lchild = insert(p->lchild,key);
   }else{
     p->rchild = insert(p->rchiild,key);
   }

}


int main(){ 
   Node *root =NULL;
   root = insert(root,30); //Thos statement helps in cretaing the first root node of a binary search tree.
   /*These steps now create new children nodes of the root node.*/
   insert(root,23);
   insert(root,10);
   return 0;



}
NOTE : The code below mentions the creation,search and deletion of Nodes of the Binary Search tree:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		Node *rchild;
};

class Binarytree{
	private:
		Node *root;
	public:
		Binarytree(){
			root =NULL;
		}
		Node *getRoot(){
			return root;
		}
		
		void insert(int key){
			Node *p,*r;
			Node *t=root;
			//If root is empty'
			if(root==NULL){
				p=new Node;
				p->data=key;
				p->lchild=NULL;
				p->rchild=NULL;
				root=p;
				return;
			}
			while(t!=NULL){
				r=t;
				if(key<t->data){
					t=t->lchild;
				}else if(key>t->data){
					t=t->rchild;
				}else{
					return;
				}
			}
			//Now t points at NULL and r at the insert position.
			p= new Node;
			p->data=key;
			p->lchild=NULL;
			p->rchild=NULL;
			
			if(key<r->data){
				r->lchild=p;
			}else{
				r->rchild=p;
			}
			
			
			
		}
		Node *search(int key){
			Node *t = root;
			while(t!=NULL){
				if(key==t->data){
					return t;
				}else if(key<t->data){
					t=t->lchild;
				}else{
					t=t->rchild;
				}
			}
			return NULL;
		}
		void inorder(Node *p){
			if(p){
				inorder(p->lchild);
				cout<<p->data;
				inorder(p->rchild);
			}
		}
		
		int Height(Node *p){
			int x,y;
			if(p==NULL){
				return 0;
			}
			x=Height(p->lchild);
			y=Height(p->rchild);
			return x>y ? x+1 : y+1;
		}
		
		Node *Inpre(Node *p){
			while(p && p->rchild!=NULL){
				p=p->rchild;
			}
			return p;
		}
		
		Node *Insucc(Node *p){
			while(p && p->lchild==NULL){
				p=p->lchild;
			}
			return p;
		}
		Node *Delete(Node *p,int key){
			Node *q;
			if(p=NULL){
				return NULL;
			}
			
			if(p->lchild==NULL && p->rchild==NULL){ //This condition for the leaf node.
				if(p==root){
					root==NULL;
					return NULL;
				}
				delete p;
				return NULL;
			}
			if(key < p->data){
				p->lchild=Delete(p->lchild,key);
			}else if(key > p->data){
				p->rchild=Delete(p->rchild,key);
			}else{
				if(Height(p->lchild) > Height(p->rchild)){  //This is to check whether the height of the left subtree is more than the left one.
					q=Inpre(p->lchild);  //If this is true then the InorderPredecessor will take its place.
					p->data = q->data;
					p->lchild=Delete(p->lchild,q->data);
				}else{
					q=Insucc(p->rchild); //Here , InorderSuccessor will take it's place.
					p->data=q->data;
					p->rchild = Delete(p->rchild,q->data);
				}
			}
			return p;
		}
		
};


int main(){
	class Binarytree bst;
	bst.insert(90);
	bst.insert(79);
	bst.insert(60);
	
	bst.inorder(bst.getRoot());
	cout<<endl;
	
	Node *temp = bst.search(60);
	if(temp!=NULL){
		cout<<"Element found:"<<temp->data<<endl;
	}else{
		cout<<"Element not found.";
	}
	
	return 0;
}

## AVL Trees :- These are BST with balanced heights. 
NOTE:- The balance factor whether the tree has optimum height,
Bf = (height of left sub-tree) - (height of right sub-tree)
Cases: (a) If Bf > 1 ,then the tree is not balanced.
(b) If Bf <= 1 ,the the tree is balanced.
There are 4 ways we can rotate our tree to make it balanced:-
(i) LL rotation
(ii) RR rotation
(iii) LR rotation
(iv) RL rotation
Note:- Rotation is performed on that node which is imbalanced.
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		int height;
		Node *rchild;
};

class AVL{
	private:
		Node *root;
	public:
		AVL(){
			root=NULL;
		}
		int Height(Node *p){
			int hl,hr;
			hl=(p && p->lchild)? p->lchild->height : 0;
			hr =(p && p->rchild) ? p->lchild->height : 0;
			
			return hl>hr ? hl+1 : hr+1;
		}
		
		int BalanceFactor(Node *p){
			int hl,hr;
			hl=(p && p->lchild)? p->lchild->height : 0;
			hr =(p && p->rchild) ? p->lchild->height : 0;
			return hl-hr;
		}
		
		Node *LLRotation(Node *p){
			Node *pl=p->lchild;
			Node *plr=pl->rchild;
			pl->rchild=p;
			p->lchild=plr;
			p->height=Height(p);
			pl->height=Height(pl);
			if(root==p){
				pl=root;
			}
			return pl;
			
		}
		
		Node *LRRotation(Node *p){
			Node *pl=p->lchild;
			Node *plr=pl->rchild;
			
			pl->rchild=plr->lchild;
			p->lchild=plr->rchild;
			
			plr->lchild=pl;
			plr->rchild=p;	
			
			pl->height=Height(pl);
			p->height=Height(p);
			plr->height=Height(plr);
			
			if(root=p){
				plr=root;
			}
			return plr;
		}
		Node *RRRotation(Node *p){
			Node *pr=p->rchild;
			Node *prl=pr->lchild;
			
			pr->lchild=p;
			p->rchild=prl;
			
			p->height=Height(p);
			pr->height=Height(pr);
			if(root==p){
				pr=root;
			}
			return pr;
		}
		
		Node *RLRotation(Node *p){
			Node *pr=p->rchild;
			Node *prl=pr->lchild;
			
			p->rchild=prl->lchild;
			pr->lchild=prl->rchild;
			
			prl->lchild=p;
			prl->rchild=pr;
			
			pr->height=Height(pr);
			p->height=Height(p);
			prl->height=Height(prl);
			
			if(root=p){
				prl=root;
			}
			return prl;
		}
		Node *Rinsert(Node *p,int key){
			Node *t=NULL;
			if(p==NULL){
				t= new Node;
				t->data=key;
				t->height=1;  /* Assumptions : Height Of node with no children = 1
				                                Height of node with single child =2 and so on...*/
				t->lchild = t->rchild =NULL;
				return t;
			}
			if(key < p->data){
				p->lchild=Rinsert(p->lchild,key);
			}else if(key > p->data){
				p->rchild=Rinsert(p->rchild,key);
			}
			p->height= Height(p); //Updating the height of each new node.
			if(BalanceFactor(p)==2 && BalanceFactor(p->lchild)==1){
				return LLRotation(p);	
			}else if (BalanceFactor(p)==2 && BalanceFactor(p->lchild)==-1){
				return LRRotation(p);
			}else if(BalanceFactor(p)==-2 && BalanceFactor(p->rchild)==-1){
				return RRRotation(p);
			}else if(BalanceFactor(p)==-2 && BalanceFactor(p->rchild)==-1){
				return RLRotation(p);
			}
			return p;
		}
		void Inorder(Node *p){
			if(p){
				Inorder(p->lchild);
				cout<<p->data<<",";
				Inorder(p->rchild);
			}
		}
		
};

int main(){
	class AVL tree;
	Node *root;
	root=tree.Rinsert(root,40);
	tree.Rinsert(root,20);
	tree.Rinsert(root,10);
	tree.Inorder(root);
	
	
	
	return 0;
}

7. Sorting techniques:
(a) Bubble Sort(Comparison Algo,O{n^2}):-
I/P:
#include<iostream>
using namespace std;
void swap(int *x,int *y){
	int temp;
	temp=*x;
	*x=*y;
	*y=temp;
}
void BubbleSort(int A[],int n){
	int i,j,flag;
	for(i=0;i<n-1;i++){
		flag =0;
		for(j=0;j<n-1-i;j++){
			if(A[j]>A[j+1]){
				swap(&A[j],&A[j+1]);
				flag=1;
			}
		}
		if(flag==0){
			break;
		}
	}
}

int main(){
	int n=10;
	int B[]={2,1,45,34,67,67,99,12,3,4};
	BubbleSort(B,n);
	for(int i=0;i<n-1;i++){
		
		cout<<B[i]<<endl;
	}
	return 0;
	
}

(b) Insetion Sort:
I/P:
#include<iostream>
#include<stdio.h>
using namespace std;

void InsertionSort(int A[],int n){
	int i,j,x;
	for(i=1;i<n;i++){
		j=i-1;
		x=A[i];
		while(j>-1 && A[j]>x){
			A[j+1] = A[j];
			j--;
		}
		A[j+1] =x;
	}
}

int main(){
	int n,i;
	int B[5]={1,20,45,23,22};
	n=5;	
	InsertionSort(B,n);
	for(i=0;i<n;i++){
		printf("%d\n",B[i]);
		
	}
	return 0;
}
(c) Selection Sort:- The following may have some kind of mistakes.
I/P:
 #include<iostream>
using namespace std;

void swap(int *x,int *y){
	int temp;
	temp =*x;
	*x=*y;
	*y=temp;
}

void SelectionSort(int A[],int n){
	int i=0;
	int k,j;
	for(i=0;i<n-1;i++){
		for(i=j=k;j<n;j++){
			if(A[j]<A[k]){
				k=j;
			}
		}
		swap(&A[i],&A[k]);
	}
}

int main(){
	int i;
	int B[5]={12,34,1,99,56};
	SelectionSort(B,5);
	for(i=0;i<5;i++){
		cout<<B[i]<<endl;
	}
	return 0;
}
(d)Quick Sort:-
I/P:
#include<iostream>
using namespace std;
void swap(int *x,int *y){
	int temp;
	temp=*x;
	*x=*y;
	*y=temp;
}

int Partiotion(int A[],int low,int high){
	int pivot=A[high];
	int i=(low -1);
	for(int j=low;j<=high-1;j++){
		if(A[j]<=pivot){
			i++;
			swap(&A[i],&A[j]);
		}
	}
	swap(&A[i+1],&A[high]);
	return (i+1);
}


void QuickSort(int arr[],int low,int high){
	if(low<high){	
		int pi = Partiotion(arr,low,high);
		Partiotion(arr,low,pi-1);
		Partiotion(arr,pi+1,high);
		
	}
}

int main(){
	
	int Array[10]={78,90,99,59,69,2,80,45,10,11};
	QuickSort(Array,0,9);
	for(int i=0;i<10;i++){
		cout<<Array[i]<<",";
	}
	
	return 0;
}
(e) Merge Sort:- Note:- Work on its general form. 
I/P: Note: check the code.
#include<iostream>
using namespace std;
void Merge(int A[], int low, int mid, int high){
    int i = low;
    int j = mid+1;
    int k = low;
    int B[high+1];
    while (i <= mid && j <= high){
        if (A[i] < A[j]){
            B[k++] = A[i++];
        } else {
            B[k++] = A[j++];
        }
    }
    while (i <= mid){
        B[k++] = A[i++];
    }
    while (j <= high){
        B[k++] = A[j++];
    }
    for (int i=low; i<=high; i++){
        A[i] = B[i];
    }
}
 void MergeSort(int arr[],int l,int h){
 	int mid;
 	if(l<h){
 		mid=(l+h)/2;
 		MergeSort(arr,l,mid);
 		MergeSort(arr,mid+1,h);
 		Merge(arr,l,mid,h);
	 }
 }
int main() {
 
    int A[] = {2, 5, 8, 12, 3, 6, 7, 10};
    int n = 8;
    MergeSort(A,0,7);
    for(int i=0;i<n;i++){
    	cout<<A[i]<<endl;
	}
   
 
    return 0;
}

(f) Count Sort:-
I/P: Note:- check the code.
#include<iostream>
using namespace std;

int Max(int A[],int n){
	int max=A[0];
	for(int i=1;i<=n;i++){
		max=A[i];

	}
	return max;	
}

void CountSort(int A[],int n){
	int i,j,max;
	int *C;
	max=Max(A,n);
	C=new int[max+1];
	for(i=0;i<max+1;i++){
		C[i]=0;
	}
	for(i=0;i<n;i++){
		C[A[i]]++;
	}
	i=j=0;
	while(j<=max+1){
		if(C[j]>0){
			A[i]=j;
			j--;
		}else{
			j++;
		}
	}
	
}

int main(){
	int n=10;
	int B[10]={34,3,99,12,23,67,69,8,10,9};
	CountSort(B,n);
	for(int i=0;i<n;i++){
		cout<<B[i]<<endl;
	}
	
	
	return 0;
}
(g) Bin/Bucket Sort:- similar to count sort.
I/P:
(h) Radix sort:- similar to bin sort
(g) shell sort
Note :- In this topic la,da factor is very important.And in every program just for easy calculation in hash function only % of 10  is used.
size if the hash table shouls be a prime number.
10. Hashing :
(a) chaining :-
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class HashTable{
	public:
		Node **HT;  //This is the array of nodes.
		int hash(int key){  //This is the hash function.
			return key%10;  
		}
		HashTable(){
			HT = new Node *[10];//This is the initialization of the hash table.
			for(int i=0;i<10;i++){
				HT[i]=NULL;
			}
		}
		void Insert(int key){
			int hldx = hash(key);
			Node *t = new Node;
			t->data= key;
			t->next=NULL;
			if(HT[hldx]=NULL){
				HT[hldx]=t;
			}else{
				Node *p =HT[hldx];
				Node *q = HT[hldx];
				while(p && p->data < key){
					q=p;
					p=p->next;
				}
				if(q==HT[hldx]){
					t->next=HT[hldx];
					HT[hldx]=t;
				}else{
					t->next=q->next;
					q->next=t;
				}
			}
		}
		
		int Search(int key){
			int hldx=hash(key);
			Node *p = HT[hldx];
			while(p){
				if(p->data==key){
					return p->data;
				}
				p=p->next;
			}
			return -1;
		}
		~HashTable() {
			for (int i=0; i<10; i++){
				Node* p = HT[i];
				while (HT[i]){
					HT[i] = HT[i]->next;
					delete p;
					p = HT[i];
				}
			}	
			delete [] HT;
		}
		
};

int main(){
	class HashTable h;
	int A[]={12,23,34,78,90,99,89,69,10};
	int n=10;
	for(int i=0;i<10;i++){
		h.Insert(A[i]);
	}
	int value = h.Search(78);
	cout<<value;
	
	
	
	return 0;
}
Closed Hashing 
(a) Linear Probing:- size of the hash table should be double the size of the elements.
I/P:
#include<iostream>
using namespace std;

int hash(int key){
	return key%10;
}
int probe(int H[],int key){
	int index = hash(key);
	int i=0;
	while(H[(index+i)%10]!=0){
		i++;
	}
	return (index+i)%10;
}
void Insert(int H[],int key){
	int index = hash(key);
	if(H[index]!=0){
		probe(H,key);
	}
	H[index]=key;
}

int Search(int H[],int key){
	int index=hash(key);
	int i=0;
	while(H[(index+i)%10]!=key){
		i++;
	}
	return (index+i)%10;
}



int main(){
	int HT[10]={0};
	Insert(HT,12);
	Insert(HT,44);
	Insert(HT,60);
	int value = Search(HT,44);
	cout<<value;
	
	
	return 0;
}
(b) Quadratic Probing:-
I/P:
#include<iostream>
using namespace std;

int hash(int key){
	return key%10;
}
int Quadraticprobe(int H[],int key){
	int index = hash(key);
	int i=0;
	while(H[(index+i*i)%10]!=0){
		i++;
	}
	return (index+i*i)%10;
}
void Insert(int H[],int key){
	int index = hash(key);
	if(H[index]!=0){
		Quadraticprobe(H,key);
	}
	H[index]=key;
}

int Search(int H[],int key){
	int index=hash(key);
	int i=0;
	while(H[(index+i*i)%10]!=key){
		i++;
	}
	return (index+i*i)%10;
}



int main(){
	int HT[10]={0};
	Insert(HT,12);
	Insert(HT,44);
	Insert(HT,60);
	int value = Search(HT,44);
	cout<<value;
	
	
	return 0;
}
(c) Double Hashing:-
I/P:
#inlcude<iostream>
#define PRIME 7  //Here PRIME is the number next smaller prime just before the last index of the hash table array(n=10,PRIME=7).
int Hash(int key){
    return key % 10;
}
 
int PrimeHash(int key){
    return PRIME - (key % PRIME);
}
 
int DoubleHash(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(Hash(idx) + i * PrimeHash(idx)) % 10] != 0){
        i++;
    }
    return (idx + i * PrimeHash(idx)) % 10;
}
 
void Insert(int H[], int key){
    int idx = Hash(key);
 
    if (H[idx] != 0){
        idx = DoubleHash(H, key);
    }
    H[idx] = key;
}
 
int Search(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(Hash(idx) + i * PrimeHash(idx)) % 10] != key){
        i++;
        if (H[(Hash(idx) + i * PrimeHash(idx)) % 10] == 0){
            return -1;
        }
    }
    return (Hash(idx) + i * PrimeHash(idx)) % 10;
}
 11. Graphs:- 
 
 
 Breadth First Search:-
 I/P:
 #include<iostream>
using namespace std;

class queue{
	public:
		int size;
		int front;
		int rear;
		int *Q;
		
		queue(){
			front = rear =-1;
			size =10;
			Q = new int[size];
			
		}
		queue(int size){
			front = rear =-1;
			this->size=size;
			Q = new int[this->size];
		}
		
		void enqueue(int x){
			if(rear == size-1){
				cout<<"Queue is full";
			}else{
				
				rear++;
				Q[rear]=x;
			}
		}
		int dequeue(){
			int x=-1;
			if(front == rear ){
				cout<<"Queue is empty";
				
			}else{
				x=Q[front+1];
				front++;
			}
			return x;
		}
		
		
};

void BFS(int vtx,int A[][8],int n){
	queue Q;
	int visited[8]={0};
	//Initially.
	cout<<vtx<<",";
	visited[vtx]=1;
	Q.enqueue(vtx);
	//Explore
	while(Q.front != Q.rear){
		int u=Q.dequeue();//Vertex u is explored.
		for(int v=1;v<n;v++){//Adjacent vertices are visited.
			if(A[u][v]==1 && visited[v]==0){
				cout<<v<<",";
				visited[v]=1;
				Q.enqueue(v);
			}
		}
		
	}
	cout<<endl;
	
}
int main (){
 
    int A[8][8] = {{0, 0, 0, 0, 0, 0, 0, 0},
                   {0, 0, 1, 1, 1, 0, 0, 0},
                   {0, 1, 0, 1, 0, 0, 0, 0},
                   {0, 1, 1, 0, 1, 1, 0, 0},
                   {0, 1, 0, 1, 0, 1, 0, 0},
                   {0, 0, 0, 1, 1, 0, 1, 1},
                   {0, 0, 0, 0, 0, 1, 0, 0},
                   {0, 0, 0, 0, 0, 1, 0, 0}};
 
    cout << "Vertex: 1 -> " << flush;
    BFS(1, A, 8);
 
 
 
    return 0;
}
(a) Prim's Algorithm:-
I/P:
#include<iostream>
#define I 32767
using namespace std;
int cost[8][8]={{I,I,I,I,I,I,I,I},
  				{I,I,25,I,I,I,5,I},
  				{I,25,I,12,I,I,I,10},
  				{I,I,12,I,8,I,I,I},
  				{I,I,I,8,I,16,I,14},
  				{I,I,I,I,16,I,20,18},
  				{I,5,I,I,I,20,I,I},
  				{I,I,10,I,14,18,I,I}};
  				
int near[8]={I,I,I,I,I,I,I,I};
int t[2][6];

int main(){
	int i,j,k,u,v,n=7,min=I;
	//Finding the min weighted edge.
	for(i=1;i<=n;i++){
		for(j=1;j<=7;j++){
			if(cost[i][j]<min){
				min=cost[i][j];
				u=i;
				v=j;
			}
		}
	}
	t[0][0]=u;//Storing the vertices of the minimum of all the edges.
	t[1][0]=v;
	near[u]=near[v]=0;
	//Comparing the edges.
	for(i=1;i<=n;i++){
		if(near[i]!=0 && cost[i][u]<cost[i][v]){
			near[i]=u;
		}else{
			near[i]=v;
		}
	}
	//Remaining edges.
	for(i=1;i<n-1;i++){
		min=I;
		for(j=1;j<=n;j++){
			if(near[j]!=0 && cost[j][near[j]]<min){
				min=cost[j][near[j]];
				k=j;
				
			}
		}
		t[0][i]=k;
		t[1][i]=near[k];
		near[k]=0;
		for(j=1;j<=n;j++){
			if(near[j]!=0 && cost[j][k]<cost[j][near[j]]){
				near[j]=k;
			}
		}
	}
    for(i=0;i<2;i++){
    	for(j=0;j<6;j++){
    		cout<<t[i][j];
		}
		cout<<endl;
	}	
	return 0;
}
--------------------------------------------
Mege Sort
#include<iostream>
using namespace std;
void Merge(int *arr,int s,int e){
    int mid=s+(e-s)/2;
    int len1=mid-s+1;
    int len2=e-mid;

    int *first=new int[len1];
    int *second = new int[len2];
    //copying the values
    int mainArrayIndex=s;
    for(int i=0;i<len1;i++){
        first[i]=arr[mainArrayIndex++];
    }
    mainArrayIndex=mid+1;
    for(int i=0;i<len2;i++){
        second[i]=arr[mainArrayIndex++];
    }

    //merging
    int index1=0;
    int index2=0;
    mainArrayIndex=s;
    while(index1<len1 && index2<len2){//this loop will run until one of the array ends
        if(first[index1]<second[index2]){
            arr[mainArrayIndex++]=first[index1++];
        }else{
            arr[mainArrayIndex++]=second[index2++];
        }
    }
    //other values which are left
    while(index1<len1){
        arr[mainArrayIndex++]=first[index1++];
    }
    while(index2<len2){
        arr[mainArrayIndex++]=second[index2++];
    }

    delete []first;
    delete []second;
}
void MergeSort(int *arr,int s,int e){
    if(s>=e){
        return;
    }

    int mid=s+(e-s)/2;
    //left part sorting
    MergeSort(arr,s,mid);
    //right part sorting
    MergeSort(arr,mid+1,e);
    //merging
    Merge(arr,s,e);
}

int main(){
    int arr[10]={4,45,32,99,12,45,3,33,9,10};
    int n=10;
    MergeSort(arr,0,n-1);
    for(int i=0;i<n;i++){
        cout<<arr[i]<<',';
    }
    cout<<"sorting done"<<endl;


    return 0;
}

