                       ----------This contains codes of Data Structures written C or C++ ----------------------
                    
  1. Binary search :
  I/P:
#include<iostream>
using namwspace std;
/* It is using iterators.*/

int Binary_Search(struct Array arr,int key){//Here, we have used struct Array and object arr.
	int l=0;
	int h = arr.length-1; //Here, .length is a class function means ut can only be applied on members of structure and classes.
	
	while(l<=h){
		int mid = (l+h)/2;
		
		if(key==arr.A[mid]){
			return mid;
		}else if(key<arr.A[mid]){
			h = mid-1;
			   
		}else{
			l= mid+1;
		}
		

	}
	return -1;
}

int main(){
	struct Array arr={{2,3,5,6},20,23}; //Here, Array is the name of the struct and arr is the name of the object.
	
    cout<<Binary_Search(arr,5); //It will only show the index number if the found element.
	
	return 0;
	
}
 
------------------------------------------------------------------------------
/*Using recursive function.*/ 
int Rbinary_Search(int A[],int l,int h, int key){
	int mid;
	if(l<=h){
		mid = (l+h)/2;
		if(key==A[mid]){
			return mid;
		}else if(key<A[mid]){
			return Rbinary_Search(A,l,mid-1,key)
		}else{
			return Rbinary_Search(A,mid+1,h,key)
		}
	}
	return -1;
}
int main(){
	int A[3]= {1,2,3};
	Rbinary_Search(A,0,2,2);
	return 0;
}



2. Revesing an array :

I/P:   
/*This method uses an another array.
int reverse(int A[]){
  int i,j;
  int B[];
  }
  for(i=A.length-1,j=0;i>=0,j>=A[].length-1;i--,j++){
      B[j] = A[i];
  }
  
  for(i=0,j=0;i>=B.length-1,j>=B.length-1;i++,j++){
      A[i] = B[j];
      }
--------------------------------------------------------------------------------
/*This one uses swapping of the elements within the array.
int main(){
   int i,j;
   for(i=0,j=A.length-1;i>=A.length-1,j=0;i++,j--){
      int temp = A[i];
      A[i] = A[j];
      A[j] = temp;
   }
}

3. Linked List:
# Creating a LL(using an array)-
I/P:
struct Node{
 int data;    //This is how a struct Node looks like but we can also use class instead of struct.
 struct Node *next; //This points to the next Node(Hence,next is the name of the pointer.)
}first;

void create(int A[],int n){
  int i;
  struct Node *t,*last;   //This wil be the first node of our linked list.
  first = new Node;
  first->data = A[0];
  first->next=NULL;
  last = first;
        
  for(i=1;i<n;i++){  //This is for the following nodes.
   t =new Node;
   t->data =A[i];
   t->next =NULL;
   last->next =t;
   last =t;
   
   
                  }

}

void display(struct Node *p){
                              //Dispalying the elements of the linked list.
  while(p!=NULL){
  cout<<p->data;
  p=p->next;
   }
}

int main(){
 int A[5] ={1,2,3,4,5}
 create(A,5);
 display(first);
 return 0;
 }
 
 ### Linked List in which user will enter all the elements: -
 
 #include <iostream>
using namespace std;
 
class Node{
public:
    int data;
    Node* next;
};
 
int main() {
 
   
 	//Creating the head node.
    Node* head = new Node;
    //Declaring the last pointer.
    Node* last;
    
 	cout<<"Enter the first element:";
    cin>>head->data;
    
    head->next = NULL;
    //The last pointer is also pointing to the head node. 
    last = head;
    
    
    while(1) {
    	int answer;
    	//Creating a nee node.
    	Node *t = new Node;
    	cout<<"\nEnter the element or 0 to exit:";
    	cin>>answer;
    	if(answer == 0) {//Checking if user want to exit
    		cout<<"\nYou have entered all the elements:\n";
    		break;
		} else {
			//Giving data to node.
			t->data = answer;
			//Since the created node is the end node hence, it's next is NULL
			t->next = NULL;
			//Giving the previous node address of the new node which is created.
			last->next = t;
			//Now, the last pointer is at the end node.
			last = t;
		}
    	
	} 
	//Declaring a pointer node for traversing through the linked list.
	Node *p;
	
	p=head; //Pointing p to the head node.
	while(p!=NULL) {
		cout<<p->data<<"\t";
		p=p->next;
	}
 
 
    return 0;
}

# Inserting An element in the LL:
 (i)Before the first Node:-
    I/P:
         Node *t = new Node;
	 t->data = 21;
	 t->next = first;  //Here, '*first' is the global declared pointer used as head fir the linked list.
	 first = t;
(ii)At nth position:- 
    I/P:We actually insert the node at (n-1) position,
          Node *t = new Node;
	  p=first;  //This is to enter the begining of the linked list.
	  for(i=0;i<pos-1;i++){  //This is to tranverse the pinter p to the desired position.
	      p=p->next;
	  }
	  t->next = p->next;  //This is the address of the next Node saved in the inserted one.
	  p->next =t;  //This is the address of the inserted in it's predecessor.
	  
                         Types of Linked List:
(a) Circular Linked List: In this type of linked list the lat node has the address to the first or head node.In this we can trevers in both the directons.

I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class LinkedList{
	
	private:
		LinkedList(){
			Node *head;
		}
	
	public:
		LinkedList(){
			Node *head =NUll;
		}
		LinkedList(int A[],int n){
			Node *t,*last;
			head= new Node;
			head->data = A[0];
			head->next=head;
			last=head;
			
			for(int i=1;i<n;i++){
				Node *t,*last;
				t=new Node;
				t->data=A[i];
				t->next=last->next;
				last->next=t;
				last=t;
				
				
			}
			
		}
		
		void Display(Node *p){
			Node *p;
			p=head;
			do{
				cout<<p->data;
				p=p->next;
			}while(p!=head);
		}
};

(b) Doubly Linked List: This is that type type of the linked list where Node contains the address of the previous and the next Node.In this we can only traverse in only one direction.
I/P:
class Node{
   public:
     Node *prev;
     int data;
     Node *next;
};

class LinkedList{
  public:
    LinkedList(int A[],int n){
       Node *t,*last;
       first = new Node;
       first->data=A[0];
       first->prev=first->next=NULL;
       last=first;
       
       for(int i=0;i>n;i++){
          Node *t,*last;
	  t= new Node;
	  t->data = A[i];
	  t->prev=last->next;
	  last->next=t;
	  last =t;
	  
	  
       }
       
  }
  
    void Display(class Node *p){
       p=first;
       while(p!=0){
         cout<<p->data;
	 p=p->next;
       }
    }
  
    
};

4. Stack:

#Creating A stack:
I/P:  This code is writtne in c_languge-
#include<iostream>
using namespace std;

struct stack{
	int size;
	int top;  //This is used to traverse thought the stack.
	int *s; // This represnts the stack itself.
};

int main(){
	
	struct stack st;
	
	cout<<"Enter the soze of the stack:";
	cin>>st.size;
	st.s = new int[st.size]; //Stack using an array.
	st.top = -1;
	
	return 0;
}
#Push funcution:
I/P:
void push(stack *st,int x){
	
	if(st->top==st->size-1){
		cout<<"Stack Overflow."
	}else{
		st->top++;  //This command lets us to iterate to the empty sapce of the stack.
	    st->s[st->top]=x;  //We are using '*s' pointer to traverse through and 'top' for accessing the indexes by using object pointer 'st'.
	}
}

#Pop function:
I/P:

int pop(stack *st){
	int x=-1;
	if(st->top==-1){
		cout<<"Stack Overflow";
	}else{
		st->s[st->top]=x;
		st->top--;
	}
	return x;
}

#Peek function:
I/P:
                                    
void peek(struct stack st,int pos){
	
	int x=-1;
	if(st.top - pos +1>0){
		cout<<"Invalid Position";
	}else{
		x=st.s[st.top - pos +1]; //This is a formula for finding out the index of the stack.
	}
	return x;
}

#Diplaying the stack:
I/P:
void Display(struct stack st){
    for(int i=top;i>=0;i--){
       cout<<st->s[i];
    }
}

----------------------------------------------------------------------------------
Stack Using Linked List: In this type we will start inserting elements from the last and to head.
# Push Function:
I/P:
struct Node{
  int data;
  Node *next;
};

struct stack{
  int size;
  stack *s;
};

void push(int x){
  Node *t= new Node;
  if(t===NULL){
    cout<<"Stack Overflow";
}else{
     t->data =x
     t->next = top;
     top=t;
     }
    }
    
 # Pop function:
 I/P:
 int pop(){
 Node *p;
 int x=-1;
 if(top==NULL){
   cout<<"Stack is empty.";
   }else{
     p=top;
     top=top->next;
     x=p->data;
     delete p;
    
   }
   return x;
 }
 
# Peek funcion:
I/P:

int peek (int pos){
  Node *p;
  int x=-1;
  for(int i=;i<pos-1;i++ && p!=0){
    p=p->next;
  }
  
  if(p!=NULL){
    return p->data;
  }else{
  return -1}
  
}
NOTE :- Stack operations using Linked List written in C++ Language:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class Stack{
	private:
		Node *top;
	public:
		Stack(){
			top == NULL;
		}
		void push(int x){
			Node *t;
			t= new Node;
			if(t==NULL){
				cout<<"Stack is empty";
			}else{
				 t->data =x;
				 t->next =top;
				 top =t;
			}
		}
		
		int pop(){
			int x=-1;
			if(top==NULL){
				cout<<"Stack is empty.";
			}else{
				x=top->data;
				Node *t = new Node;
				t=top;
				top=top->next;
				delete t;
				return x;
			}
		}
		void Display(){
			Node *p;
			while(p!=NULL){
				cout<<p->data;
				p=p->next;
			}
		}
};

int main(){
	Stack st;
	st.push(12);
	st.push(20);
	st.push(30);
	st.Display();
	return 0;
}

5. Queues :- Follows FIFO property.
# Using an array: 
I/P:
NOTE:- Following codes are written in C language.
struct queue{    //This is how a queue's structure should look like.
	int size;
	int front;
	int rear;
	int *Q;
};


int main(){
	
	struct queue q;    //Initializing a queue.
	cout<<"Enter the size of the queue:";
	cin>>q.size;
	
	q.Q = new queue;
	q.front=q.rear=-1;
	
	return 0;
}

# Enqueue function:
I/P:
void enqueue(queue *q,int x){
	if(q->rear==q->size-1){
		cout<<"Queue is full";
	}else{
		cout<<"Enter the value you want to enter:";
		cin>>x;
		q->rear++;
		q->Q[q->rear]=x;
		
	}
	
	
}
# Dequeue function:
I/P:
int dequeue(queue *q){
   int x=-1;
   if(q->front==q->rear){
      cout<<"Queue is empty";
   }else{
      q->front++;
      x=q->Q[q->rear];
   }
   return x;
}
--------------------------------------------------------
Note: The code written below is written in C++ languge:
I/P:
#include<iostream>
using namespace std;

class queue{
	private:
		int size;
		int front;
		int rear;
		int *Q;
		
	
	public:
		queue(){
			front = rear =-1;
			size =10;
			Q = new int[size];
			
		}
		queue(int size){
			front = rear =-1;
			this->size=size;
			Q = new int[this->size];
		}
		
		void enqueue(int x){
			if(rear == size-1){
				cout<<"Queue is full";
			}else{
				
				rear++;
				Q[rear]=x;
			}
		}
		int dequeue(){
			int x=-1;
			if(front == rear ){
				cout<<"Queue is empty";
				
			}else{
				x=Q[front+1];
				front++;
			}
			return x;
		}
		
		void Display(){
			for(int i=front+1;i<=rear;i++){
				cout<<Q[i];
			}
		}
};


int main(){
	
		queue q(3);
		q.enqueue(10);
		q.enqueue(23);
		q.enqueue(45);
		q.Display();
		
	
	return 0;
}
                  Circular Queue (Differences can be spot in enqueue,dequeue and the display function):
I/P:
#include<iostream>
using namespace std;

class queue{
	private:
		int size;
		int front;
		int rear;
		int *Q;
		
	
	public:
		queue(){
			front = rear =-1;
			size =10;
			Q = new int[size];
			
		}
		queue(int size){
			front = rear =-1;
			this->size=size;
			Q = new int[this->size];
		}
		
		void enqueue(int x){
			if((rear+1)% this->size==front){
				cout<<"Queue is full";
			}else{
				
				rear = (rear+1) % this->size;
				Q[rear]=x;
			}
		}
		int dequeue(){
			int x=-1;
			if(front == rear ){
				cout<<"Queue is empty";
				
			}else{
				front = (front+1)% this->size;
				x=Q[front+1];
				
			}
			return x;
		}
		
		void Display(){
			
			int i=front+1;
			do{
			    cout<<Q[i];
			    i=(i+1)% this->size;
			}while(i!=(rear+1)% this->size);
			
		}
};


int main(){
	
		queue q(3);
		
		q.enqueue(10);
		q.enqueue(23);
		q.enqueue(45);
		q.Display();
		
	
	return 0;
}

## Queue using Linked List:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
    	Node *next;
};

class queue{
	private:
		Node *front;
		Node *rear;
	
	public:
		queue(){
			front = NULL;
			rear = NULL;
		}
		~queue(){
			Node *p;
			while(front){
				p=front;
				delete p;
				front = front->next;
			}
		}
		
		void enqueue(int x){
			
			Node *t = new Node;
			if(t==NULL){
				cout<<"Queue is full.";
			}else{
				t->data=x;
				t->next=NULL;
				if(front==NULL){
					front =rear =t;
				}else{
					rear =t;
					rear->next=NULL;
				}
			}
			
		int dequeue(){
				int x=-1;
				Node *p;
				if(front==NULL){
					cout<<"Queue is empty.";
				}else{
					p=front;
					x=p->data;
					front=front->next;
					delete p;
				}
			}
			
		void Display(){
				Node *p=front;
				
				while(p){
					cout<<p->data;
					p=p->next;
				
				}
			}
			
		
};


int main(){
	
	queue q;
	q.enqueue(12);
	q.enqueue(23);
	q.enqueue(24);
	q.Display();
	
	return 0;
}

6. Trees:-

Using Linked List-
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		Node *rchild;
};

class Queue{
	private:
		int size;
		int front;
		int rear;
		Node **Q;
		
	public:
		Queue(int size){
			this->size=size;
			front=rear=-1;
			Q = new Node* [size];
		}
		
		~Queue(){
			delete []Q;
		}
		
		bool isEmpty(){
			if(front==rear){
				return true;
			}else{
				return false;
			}
		}
		
		bool isFull(){
			if(rear==size-1){
				return true;
			}else{
				return false;
			}
		}
		
		void enqueue(Node *x){
			if(isFull()){
				cout<<"Queue overflow.";
			}else{
				rear++;
				Q[rear]=x;
			}
			
		}
		
		Node *dequeue(){
			
			Node *x = NULL;
			if(isEmpty()){
				cout<<"Queue is Empty.";
			}else{
				front++;
				x=Q[front];
			}
			return x;
		}
};

Node *root = new Node;

void Treecreate(){
	Node *p;
	Node *t;
	Queue q(10);
	int x;
	cout<<"Enter the root of the tree:";
	cin>>x;
	root->data =x;
	root->lchild = NULL;
	root->rchild=NULL;
	q.enqueue(root);
	while(!q.isEmpty()){
		p=q.dequeue();
		
		cout<<"Enter the value of the left child of  "<<p->data<<":";
		cin>>x;
		if(x!=-1){
			t =new Node;
			t->data=x;
			t->lchild=NULL;
			t->rchild=NULL;
			p->lchild=t;
			q.enqueue(t);
		}
		cout<<"Enter the value of right child of "<<p->data<<":";
		cin>>x;
		if(x!=-1){
			t= new Node;
			t->data=x;
			t->lchild=NULL;
			t->rchild=NULL;
			p->rchild=t;
			q.enqueue(t);
		}
	}
	
	
}

void preorder(Node *p){
	if(p){
		cout<<p->data<<",";
		preorder(p->lchild);
		preorder(p->rchild);
	}
}

void inorder(Node *p){
	if(p){
		inorder(p->lchild);
		cout<<p->data<<",";
		inorder(p->rchild);
	}
}

void postorder(Node *p){
	if(p){
		preorder(p->lchild);
		preorder(p->rchild);
		cout<<p->data<<",";
	}
}

int main(){
	Treecreate();
	preorder(root);
	cout<<endl;
	
}

## Counting number of nodes in a Binary tree:-
I/P:
int count(Node *p){  //This funcntion is used to count the number of nodes in a tree.
    int x,y;
    if(p!=NULL){
       	x=count(p->lchild);
	y=count(p->rchild);
	return x+y+1;
    }
    return 0;
}

int count(Node *p){   //This function will count number of nodes with degree 2 or nodes with two children.
   int x,y;
   if(p!=NULL){
      x=count(p->lchild);
      y=count(p->rchild);
      if(p->lchild && p->rchild){
          return x+y+1;
	  }else{
	     return x+y;
	  }
	  return 0;
   }
}


## Binary Search Tree:-
(a) Searching -
I/P: 
int Rsearch(Node *t,int key){
    cout<<"Enter the key you want to search:";;
    cin>>key;
    if(t==NULL){
      return t;    //This function uses recursive call to search
    }else(
       if(key==t->data){
          reutn t;
       }else if(key>p->data){
          return Rsearch(p->lchild,key);
       }else{
          return Rsearch(p->rchild,key);
       }
    )
}

/* This funcction uses search iteratively.*/
Node *search(Node *t,int key){
   cout<<"Enter the key value you want to search:";
   cin>>key;
   while(t!=NULL){
     if(key==t->data){
        return t;
     }else if(key<t->data){
        t=t->lchild;
     }else{
        t=t->rchild;
     }
     
   }
   return NULL;
   
## Inserting Node in a Binary search tree:
I/P:
void insert(Node *t,int key){
  cout<<"Enter the key you want to insert:";
  cin>>key;
  
  Node *r=NULL;*t;
  while(t!=NULL){
     r=t;
     if(key==t->data){
        return;
     }else if(key<t->data){ 
        t=t->lchild;
     
     }else{
        t=t->rchild;
     }
    }
     Node *p = new Node;
     p->lchild = p->rchild = NULL;
     p->data = key;
     if(p->data<r->data){
        r->lchild = p;
     }else{
        r->rchild = p;
     }
  }
  /* This Insert function is written in recursive form form.
Node *insert(Node *p,int key){
   Node *t;
   if(p=NULL){
      t= new Node;
      t->data =key;
      t->lchild = t->rchild = NULL;
      return t;
   }
   if(key<p->data){
     p->lchild = insert(p->lchild,key);
   }else{
     p->rchild = insert(p->rchiild,key);
   }

}


int main(){ 
   Node *root =NULL;
   root = insert(root,30); //Thos statement helps in cretaing the first root node of a binary search tree.
   /*These steps now create new children nodes of the root node.*/
   insert(root,23);
   insert(root,10);
   return 0;



}
NOTE : The code below mentions the creation,search and deletion of Nodes of the Binary Search tree:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		Node *rchild;
};

class Binarytree{
	private:
		Node *root;
	public:
		Binarytree(){
			root =NULL;
		}
		Node *getRoot(){
			return root;
		}
		
		void insert(int key){
			Node *p,*r;
			Node *t=root;
			//If root is empty'
			if(root==NULL){
				p=new Node;
				p->data=key;
				p->lchild=NULL;
				p->rchild=NULL;
				root=p;
				return;
			}
			while(t!=NULL){
				r=t;
				if(key<t->data){
					t=t->lchild;
				}else if(key>t->data){
					t=t->rchild;
				}else{
					return;
				}
			}
			//Now t points at NULL and r at the insert position.
			p= new Node;
			p->data=key;
			p->lchild=NULL;
			p->rchild=NULL;
			
			if(key<r->data){
				r->lchild=p;
			}else{
				r->rchild=p;
			}
			
			
			
		}
		Node *search(int key){
			Node *t = root;
			while(t!=NULL){
				if(key==t->data){
					return t;
				}else if(key<t->data){
					t=t->lchild;
				}else{
					t=t->rchild;
				}
			}
			return NULL;
		}
		void inorder(Node *p){
			if(p){
				inorder(p->lchild);
				cout<<p->data;
				inorder(p->rchild);
			}
		}
		
		int Height(Node *p){
			int x,y;
			if(p==NULL){
				return 0;
			}
			x=Height(p->lchild);
			y=Height(p->rchild);
			return x>y ? x+1 : y+1;
		}
		
		Node *Inpre(Node *p){
			while(p && p->rchild!=NULL){
				p=p->rchild;
			}
			return p;
		}
		
		Node *Insucc(Node *p){
			while(p && p->lchild==NULL){
				p=p->lchild;
			}
			return p;
		}
		Node *Delete(Node *p,int key){
			Node *q;
			if(p=NULL){
				return NULL;
			}
			
			if(p->lchild==NULL && p->rchild==NULL){ //This condition for the leaf node.
				if(p==root){
					root==NULL;
					return NULL;
				}
				delete p;
				return NULL;
			}
			if(key < p->data){
				p->lchild=Delete(p->lchild,key);
			}else if(key > p->data){
				p->rchild=Delete(p->rchild,key);
			}else{
				if(Height(p->lchild) > Height(p->rchild)){  //This is to check whether the height of the left subtree is more than the left one.
					q=Inpre(p->lchild);  //If this is true then the InorderPredecessor will take its place.
					p->data = q->data;
					p->lchild=Delete(p->lchild,q->data);
				}else{
					q=Insucc(p->rchild); //Here , InorderSuccessor will take it's place.
					p->data=q->data;
					p->rchild = Delete(p->rchild,q->data);
				}
			}
			return p;
		}
		
};


int main(){
	class Binarytree bst;
	bst.insert(90);
	bst.insert(79);
	bst.insert(60);
	
	bst.inorder(bst.getRoot());
	cout<<endl;
	
	Node *temp = bst.search(60);
	if(temp!=NULL){
		cout<<"Element found:"<<temp->data<<endl;
	}else{
		cout<<"Element not found.";
	}
	
	return 0;
}

## AVL Trees :- These are BST with balanced heights. 
NOTE:- The balance factor whether the tree has optimum height,
Bf = (height of left sub-tree) - (height of right sub-tree)
Cases: (a) If Bf > 1 ,then the tree is not balanced.
(b) If Bf <= 1 ,the the tree is balanced.
There are 4 ways we can rotate our tree to make it balanced:-
(i) LL rotation
(ii) RR rotation
(iii) LR rotation
(iv) RL rotation
Note:- Rotation is performed on that node which is imbalanced.
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		int height;
		Node *rchild;
};

class AVL{
	private:
		Node *root;
	public:
		AVL(){
			root=NULL;
		}
		int Height(Node *p){
			int hl,hr;
			hl=(p && p->lchild)? p->lchild->height : 0;
			hr =(p && p->rchild) ? p->lchild->height : 0;
			
			return hl>hr ? hl+1 : hr+1;
		}
		
		int BalanceFactor(Node *p){
			int hl,hr;
			hl=(p && p->lchild)? p->lchild->height : 0;
			hr =(p && p->rchild) ? p->lchild->height : 0;
			return hl-hr;
		}
		
		Node *LLRotation(Node *p){
			Node *pl=p->lchild;
			Node *plr=pl->rchild;
			pl->rchild=p;
			p->lchild=plr;
			p->height=Height(p);
			pl->height=Height(pl);
			if(root==p){
				pl=root;
			}
			return pl;
			
		}
		
		Node *LRRotation(Node *p){
			Node *pl=p->lchild;
			Node *plr=pl->rchild;
			
			pl->rchild=plr->lchild;
			p->lchild=plr->rchild;
			
			plr->lchild=pl;
			plr->rchild=p;	
			
			pl->height=Height(pl);
			p->height=Height(p);
			plr->height=Height(plr);
			
			if(root=p){
				plr=root;
			}
			return plr;
		}
		Node *RRRotation(Node *p){
			Node *pr=p->rchild;
			Node *prl=pr->lchild;
			
			pr->lchild=p;
			p->rchild=prl;
			
			p->height=Height(p);
			pr->height=Height(pr);
			if(root==p){
				pr=root;
			}
			return pr;
		}
		
		Node *RLRotation(Node *p){
			Node *pr=p->rchild;
			Node *prl=pr->lchild;
			
			p->rchild=prl->lchild;
			pr->lchild=prl->rchild;
			
			prl->lchild=p;
			prl->rchild=pr;
			
			pr->height=Height(pr);
			p->height=Height(p);
			prl->height=Height(prl);
			
			if(root=p){
				prl=root;
			}
			return prl;
		}
		Node *Rinsert(Node *p,int key){
			Node *t=NULL;
			if(p==NULL){
				t= new Node;
				t->data=key;
				t->height=1;  /* Assumptions : Height Of node with no children = 1
				                                Height of node with single child =2 and so on...*/
				t->lchild = t->rchild =NULL;
				return t;
			}
			if(key < p->data){
				p->lchild=Rinsert(p->lchild,key);
			}else if(key > p->data){
				p->rchild=Rinsert(p->rchild,key);
			}
			p->height= Height(p); //Updating the height of each new node.
			if(BalanceFactor(p)==2 && BalanceFactor(p->lchild)==1){
				return LLRotation(p);	
			}else if (BalanceFactor(p)==2 && BalanceFactor(p->lchild)==-1){
				return LRRotation(p);
			}else if(BalanceFactor(p)==-2 && BalanceFactor(p->rchild)==-1){
				return RRRotation(p);
			}else if(BalanceFactor(p)==-2 && BalanceFactor(p->rchild)==-1){
				return RLRotation(p);
			}
			return p;
		}
		void Inorder(Node *p){
			if(p){
				Inorder(p->lchild);
				cout<<p->data<<",";
				Inorder(p->rchild);
			}
		}
		
};

int main(){
	class AVL tree;
	Node *root;
	root=tree.Rinsert(root,40);
	tree.Rinsert(root,20);
	tree.Rinsert(root,10);
	tree.Inorder(root);
	
	
	
	return 0;
}

7. Sorting techniques:
(a) Bubble Sort(Comparison Algo,O{n^2}):-
I/P:
#include<iostream>
using namespace std;
void swap(int *x,int *y){
	int temp;
	temp=*x;
	*x=*y;
	*y=temp;
}
void BubbleSort(int A[],int n){
	int i,j,flag;
	for(i=0;i<n-1;i++){
		flag =0;
		for(j=0;j<n-1-i;j++){
			if(A[j]>A[j+1]){
				swap(&A[j],&A[j+1]);
				flag=1;
			}
		}
		if(flag==0){
			break;
		}
	}
}

int main(){
	int n=10;
	int B[]={2,1,45,34,67,67,99,12,3,4};
	BubbleSort(B,n);
	for(int i=0;i<n-1;i++){
		
		cout<<B[i]<<endl;
	}
	return 0;
	
}

(b) Insetion Sort:
I/P:
#include<iostream>
#include<stdio.h>
using namespace std;

void InsertionSort(int A[],int n){
	int i,j,x;
	for(i=1;i<n;i++){
		j=i-1;
		x=A[i];
		while(j>-1 && A[j]>x){
			A[j+1] = A[j];
			j--;
		}
		A[j+1] =x;
	}
}

int main(){
	int n,i;
	int B[5]={1,20,45,23,22};
	n=5;	
	InsertionSort(B,n);
	for(i=0;i<n;i++){
		printf("%d\n",B[i]);
		
	}
	return 0;
}
(c) Selection Sort:- The following may have some kind of mistakes.
I/P:
 #include<iostream>
using namespace std;

void swap(int *x,int *y){
	int temp;
	temp =*x;
	*x=*y;
	*y=temp;
}

void SelectionSort(int A[],int n){
	int i=0;
	int k,j;
	for(i=0;i<n-1;i++){
		for(i=j=k;j<n;j++){
			if(A[j]<A[k]){
				k=j;
			}
		}
		swap(&A[i],&A[k]);
	}
}

int main(){
	int i;
	int B[5]={12,34,1,99,56};
	SelectionSort(B,5);
	for(i=0;i<5;i++){
		cout<<B[i]<<endl;
	}
	return 0;
}
(d)Quick Sort:-
I/P:
#include<iostream>
using namespace std;
void swap(int *x,int *y){
	int temp;
	temp=*x;
	*x=*y;
	*y=temp;
}

int Partiotion(int A[],int low,int high){
	int pivot=A[high];
	int i=(low -1);
	for(int j=low;j<=high-1;j++){
		if(A[j]<=pivot){
			i++;
			swap(&A[i],&A[j]);
		}
	}
	swap(&A[i+1],&A[high]);
	return (i+1);
}


void QuickSort(int arr[],int low,int high){
	if(low<high){	
		int pi = Partiotion(arr,low,high);
		Partiotion(arr,low,pi-1);
		Partiotion(arr,pi+1,high);
		
	}
}

int main(){
	
	int Array[10]={78,90,99,59,69,2,80,45,10,11};
	QuickSort(Array,0,9);
	for(int i=0;i<10;i++){
		cout<<Array[i]<<",";
	}
	
	return 0;
}
(e) Merge Sort:- Note:- Work on its general form. 
I/P: Note: check the code.
#include<iostream>
using namespace std;
void Merge(int A[], int low, int mid, int high){
    int i = low;
    int j = mid+1;
    int k = low;
    int B[high+1];
    while (i <= mid && j <= high){
        if (A[i] < A[j]){
            B[k++] = A[i++];
        } else {
            B[k++] = A[j++];
        }
    }
    while (i <= mid){
        B[k++] = A[i++];
    }
    while (j <= high){
        B[k++] = A[j++];
    }
    for (int i=low; i<=high; i++){
        A[i] = B[i];
    }
}
 void MergeSort(int arr[],int l,int h){
 	int mid;
 	if(l<h){
 		mid=(l+h)/2;
 		MergeSort(arr,l,mid);
 		MergeSort(arr,mid+1,h);
 		Merge(arr,l,mid,h);
	 }
 }
int main() {
 
    int A[] = {2, 5, 8, 12, 3, 6, 7, 10};
    int n = 8;
    MergeSort(A,0,7);
    for(int i=0;i<n;i++){
    	cout<<A[i]<<endl;
	}
   
 
    return 0;
}

(f) Count Sort:-
I/P: Note:- check the code.
#include<iostream>
using namespace std;

int Max(int A[],int n){
	int max=A[0];
	for(int i=1;i<=n;i++){
		max=A[i];

	}
	return max;	
}

void CountSort(int A[],int n){
	int i,j,max;
	int *C;
	max=Max(A,n);
	C=new int[max+1];
	for(i=0;i<max+1;i++){
		C[i]=0;
	}
	for(i=0;i<n;i++){
		C[A[i]]++;
	}
	i=j=0;
	while(j<=max+1){
		if(C[j]>0){
			A[i]=j;
			j--;
		}else{
			j++;
		}
	}
	
}

int main(){
	int n=10;
	int B[10]={34,3,99,12,23,67,69,8,10,9};
	CountSort(B,n);
	for(int i=0;i<n;i++){
		cout<<B[i]<<endl;
	}
	
	
	return 0;
}
(g) Bin/Bucket Sort:- similar to count sort.
I/P:
(h) Radix sort:- similar to bin sort
(g) shell sort
Note :- In this topic la,da factor is very important.And in every program just for easy calculation in hash function only % of 10  is used.
size if the hash table shouls be a prime number.
10. Hashing :
(a) chaining :-
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class HashTable{
	public:
		Node **HT;  //This is the array of nodes.
		int hash(int key){  //This is the hash function.
			return key%10;  
		}
		HashTable(){
			HT = new Node *[10];//This is the initialization of the hash table.
			for(int i=0;i<10;i++){
				HT[i]=NULL;
			}
		}
		void Insert(int key){
			int hldx = hash(key);
			Node *t = new Node;
			t->data= key;
			t->next=NULL;
			if(HT[hldx]=NULL){
				HT[hldx]=t;
			}else{
				Node *p =HT[hldx];
				Node *q = HT[hldx];
				while(p && p->data < key){
					q=p;
					p=p->next;
				}
				if(q==HT[hldx]){
					t->next=HT[hldx];
					HT[hldx]=t;
				}else{
					t->next=q->next;
					q->next=t;
				}
			}
		}
		
		int Search(int key){
			int hldx=hash(key);
			Node *p = HT[hldx];
			while(p){
				if(p->data==key){
					return p->data;
				}
				p=p->next;
			}
			return -1;
		}
		~HashTable() {
			for (int i=0; i<10; i++){
				Node* p = HT[i];
				while (HT[i]){
					HT[i] = HT[i]->next;
					delete p;
					p = HT[i];
				}
			}	
			delete [] HT;
		}
		
};

int main(){
	class HashTable h;
	int A[]={12,23,34,78,90,99,89,69,10};
	int n=10;
	for(int i=0;i<10;i++){
		h.Insert(A[i]);
	}
	int value = h.Search(78);
	cout<<value;
	
	
	
	return 0;
}
Closed Hashing 
(a) Linear Probing:- size of the hash table should be double the size of the elements.
I/P:
#include<iostream>
using namespace std;

int hash(int key){
	return key%10;
}
int probe(int H[],int key){
	int index = hash(key);
	int i=0;
	while(H[(index+i)%10]!=0){
		i++;
	}
	return (index+i)%10;
}
void Insert(int H[],int key){
	int index = hash(key);
	if(H[index]!=0){
		probe(H,key);
	}
	H[index]=key;
}

int Search(int H[],int key){
	int index=hash(key);
	int i=0;
	while(H[(index+i)%10]!=key){
		i++;
	}
	return (index+i)%10;
}



int main(){
	int HT[10]={0};
	Insert(HT,12);
	Insert(HT,44);
	Insert(HT,60);
	int value = Search(HT,44);
	cout<<value;
	
	
	return 0;
}
(b) Quadratic Probing:-
I/P:
#include<iostream>
using namespace std;

int hash(int key){
	return key%10;
}
int Quadraticprobe(int H[],int key){
	int index = hash(key);
	int i=0;
	while(H[(index+i*i)%10]!=0){
		i++;
	}
	return (index+i*i)%10;
}
void Insert(int H[],int key){
	int index = hash(key);
	if(H[index]!=0){
		Quadraticprobe(H,key);
	}
	H[index]=key;
}

int Search(int H[],int key){
	int index=hash(key);
	int i=0;
	while(H[(index+i*i)%10]!=key){
		i++;
	}
	return (index+i*i)%10;
}



int main(){
	int HT[10]={0};
	Insert(HT,12);
	Insert(HT,44);
	Insert(HT,60);
	int value = Search(HT,44);
	cout<<value;
	
	
	return 0;
}
(c) Double Hashing:-
I/P:
#inlcude<iostream>
#define PRIME 7  //Here PRIME is the number next smaller prime just before the last index of the hash table array(n=10,PRIME=7).
int Hash(int key){
    return key % 10;
}
 
int PrimeHash(int key){
    return PRIME - (key % PRIME);
}
 
int DoubleHash(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(Hash(idx) + i * PrimeHash(idx)) % 10] != 0){
        i++;
    }
    return (idx + i * PrimeHash(idx)) % 10;
}
 
void Insert(int H[], int key){
    int idx = Hash(key);
 
    if (H[idx] != 0){
        idx = DoubleHash(H, key);
    }
    H[idx] = key;
}
 
int Search(int H[], int key){
    int idx = Hash(key);
    int i = 0;
    while (H[(Hash(idx) + i * PrimeHash(idx)) % 10] != key){
        i++;
        if (H[(Hash(idx) + i * PrimeHash(idx)) % 10] == 0){
            return -1;
        }
    }
    return (Hash(idx) + i * PrimeHash(idx)) % 10;
}
 11. Graphs:- 
 
 
 Breadth First Search:-
 I/P:
 #include<iostream>
using namespace std;

class queue{
	public:
		int size;
		int front;
		int rear;
		int *Q;
		
		queue(){
			front = rear =-1;
			size =10;
			Q = new int[size];
			
		}
		queue(int size){
			front = rear =-1;
			this->size=size;
			Q = new int[this->size];
		}
		
		void enqueue(int x){
			if(rear == size-1){
				cout<<"Queue is full";
			}else{
				
				rear++;
				Q[rear]=x;
			}
		}
		int dequeue(){
			int x=-1;
			if(front == rear ){
				cout<<"Queue is empty";
				
			}else{
				x=Q[front+1];
				front++;
			}
			return x;
		}
		
		
};

void BFS(int vtx,int A[][8],int n){
	queue Q;
	int visited[8]={0};
	//Initially.
	cout<<vtx<<",";
	visited[vtx]=1;
	Q.enqueue(vtx);
	//Explore
	while(Q.front != Q.rear){
		int u=Q.dequeue();//Vertex u is explored.
		for(int v=1;v<n;v++){//Adjacent vertices are visited.
			if(A[u][v]==1 && visited[v]==0){
				cout<<v<<",";
				visited[v]=1;
				Q.enqueue(v);
			}
		}
		
	}
	cout<<endl;
	
}
int main (){
 
    int A[8][8] = {{0, 0, 0, 0, 0, 0, 0, 0},
                   {0, 0, 1, 1, 1, 0, 0, 0},
                   {0, 1, 0, 1, 0, 0, 0, 0},
                   {0, 1, 1, 0, 1, 1, 0, 0},
                   {0, 1, 0, 1, 0, 1, 0, 0},
                   {0, 0, 0, 1, 1, 0, 1, 1},
                   {0, 0, 0, 0, 0, 1, 0, 0},
                   {0, 0, 0, 0, 0, 1, 0, 0}};
 
    cout << "Vertex: 1 -> " << flush;
    BFS(1, A, 8);
 
 
 
    return 0;
}
(a) Prim's Algorithm:-
I/P:
#include<iostream>
#define I 32767
using namespace std;
int cost[8][8]={{I,I,I,I,I,I,I,I},
  				{I,I,25,I,I,I,5,I},
  				{I,25,I,12,I,I,I,10},
  				{I,I,12,I,8,I,I,I},
  				{I,I,I,8,I,16,I,14},
  				{I,I,I,I,16,I,20,18},
  				{I,5,I,I,I,20,I,I},
  				{I,I,10,I,14,18,I,I}};
  				
int near[8]={I,I,I,I,I,I,I,I};
int t[2][6];

int main(){
	int i,j,k,u,v,n=7,min=I;
	//Finding the min weighted edge.
	for(i=1;i<=n;i++){
		for(j=1;j<=7;j++){
			if(cost[i][j]<min){
				min=cost[i][j];
				u=i;
				v=j;
			}
		}
	}
	t[0][0]=u;//Storing the vertices of the minimum of all the edges.
	t[1][0]=v;
	near[u]=near[v]=0;
	//Comparing the edges.
	for(i=1;i<=n;i++){
		if(near[i]!=0 && cost[i][u]<cost[i][v]){
			near[i]=u;
		}else{
			near[i]=v;
		}
	}
	//Remaining edges.
	for(i=1;i<n-1;i++){
		min=I;
		for(j=1;j<=n;j++){
			if(near[j]!=0 && cost[j][near[j]]<min){
				min=cost[j][near[j]];
				k=j;
				
			}
		}
		t[0][i]=k;
		t[1][i]=near[k];
		near[k]=0;
		for(j=1;j<=n;j++){
			if(near[j]!=0 && cost[j][k]<cost[j][near[j]]){
				near[j]=k;
			}
		}
	}
    for(i=0;i<2;i++){
    	for(j=0;j<6;j++){
    		cout<<t[i][j];
		}
		cout<<endl;
	}	
	return 0;
}

