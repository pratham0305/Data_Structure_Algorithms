                       ----------This contains codes of Data Structures written C or C++ ----------------------
                    
  1. Binary search :
  I/P:
#include<iostream>
using namwspace std;
/* It is using iterators.*/

int Binary_Search(struct Array arr,int key){//Here, we have used struct Array and object arr.
	int l=0;
	int h = arr.length-1; //Here, .length is a class function means ut can only be applied on members of structure and classes.
	
	while(l<=h){
		int mid = (l+h)/2;
		
		if(key==arr.A[mid]){
			return mid;
		}else if(key<arr.A[mid]){
			h = mid-1;
			   
		}else{
			l= mid+1;
		}
		

	}
	return -1;
}

int main(){
	struct Array arr={{2,3,5,6},20,23}; //Here, Array is the name of the struct and arr is the name of the object.
	
    cout<<Binary_Search(arr,5); //It will only show the index number if the found element.
	
	return 0;
	
}
 
------------------------------------------------------------------------------
/*Using recursive function.*/ 
int Rbinary_Search(int A[],int l,int h, int key){
	int mid;
	if(l<=h){
		mid = (l+h)/2;
		if(key==A[mid]){
			return mid;
		}else if(key<A[mid]){
			return Rbinary_Search(A,l,mid-1,key)
		}else{
			return Rbinary_Search(A,mid+1,h,key)
		}
	}
	return -1;
}
int main(){
	int A[3]= {1,2,3};
	Rbinary_Search(A,0,2,2);
	return 0;
}



2. Revesing an array :

I/P:   
/*This method uses an another array.
int reverse(int A[]){
  int i,j;
  int B[];
  }
  for(i=A.length-1,j=0;i>=0,j>=A[].length-1;i--,j++){
      B[j] = A[i];
  }
  
  for(i=0,j=0;i>=B.length-1,j>=B.length-1;i++,j++){
      A[i] = B[j];
      }
--------------------------------------------------------------------------------
/*This one uses swapping of the elements within the array.
int main(){
   int i,j;
   for(i=0,j=A.length-1;i>=A.length-1,j=0;i++,j--){
      int temp = A[i];
      A[i] = A[j];
      A[j] = temp;
   }
}

3. Linked List:
# Creating a LL(using an array)-
I/P:
struct Node{
 int data;    //This is how a struct Node looks like but we can also use class instead of struct.
 struct Node *next; //This points to the next Node(Hence,next is the name of the pointer.)
}first;

void create(int A[],int n){
  int i;
  struct Node *t,*last;   //This wil be the first node of our linked list.
  first = new Node;
  first->data = A[0];
  first->next=NULL;
  last = first;
        
  for(i=1;i<n;i++){  //This is for the following nodes.
   t =new Node;
   t->data =A[i];
   t->next =NULL;
   last->next =t;
   last =t;
   
   
                  }

}

void display(struct Node *p){
                              //Dispalying the elements of the linked list.
  while(p!=NULL){
  cout<<p->data;
  p=p->next;
   }
}

int main(){
 int A[5] ={1,2,3,4,5}
 create(A,5);
 display(first);
 return 0;
 }
# Inserting An element in the LL:
 (i)Before the first Node:-
    I/P:
         Node *t = new Node;
	 t->data = 21;
	 t->next = first;  //Here, '*first' is the global declared pointer used as head fir the linked list.
	 first = t;
(ii)At nth position:- 
    I/P:We actually insert the node at (n-1) position,
          Node *t = new Node;
	  p=first;  //This is to enter the begining of the linked list.
	  for(i=0;i<pos-1;i++){  //This is to tranverse the pinter p to the desired position.
	      p=p->next;
	  }
	  t->next = p->next;  //This is the address of the next Node saved in the inserted one.
	  p->next =t;  //This is the address of the inserted in it's predecessor.
	  
                         Types of Linked List:
(a) Circular Linked List: In this type of linked list the lat node has the address to the first or head node.In this we can trevers in both the directons.

I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class LinkedList{
	
	private:
		LinkedList(){
			Node *head;
		}
	
	public:
		LinkedList(){
			Node *head =NUll;
		}
		LinkedList(int A[],int n){
			Node *t,*last;
			head= new Node;
			head->data = A[0];
			head->next=head;
			last=head;
			
			for(int i=1;i<n;i++){
				Node *t,*last;
				t=new Node;
				t->data=A[i];
				t->next=last->next;
				last->next=t;
				last=t;
				
				
			}
			
		}
		
		void Display(Node *p){
			Node *p;
			p=head;
			do{
				cout<<p->data;
				p=p->next;
			}while(p!=head);
		}
};

(b) Doubly Linked List: This is that type type of the linked list where Node contains the address of the previous and the next Node.In this we can only traverse in only one direction.
I/P:
class Node{
   public:
     Node *prev;
     int data;
     Node *next;
};

class LinkedList{
  public:
    LinkedList(int A[],int n){
       Node *t,*last;
       first = new Node;
       first->data=A[0];
       first->prev=first->next=NULL;
       last=first;
       
       for(int i=0;i>n;i++){
          Node *t,*last;
	  t= new Node;
	  t->data = A[i];
	  t->prev=last->next;
	  last->next=t;
	  last =t;
	  
	  
       }
       
  }
  
    void Display(class Node *p){
       p=first;
       while(p!=0){
         cout<<p->data;
	 p=p->next;
       }
    }
  
    
};

4. Stack:

#Creating A stack:
I/P:  This code is writtne in c_languge-
#include<iostream>
using namespace std;

struct stack{
	int size;
	int top;  //This is used to traverse thought the stack.
	int *s; // This represnts the stack itself.
};

int main(){
	
	struct stack st;
	
	cout<<"Enter the soze of the stack:";
	cin>>st.size;
	st.s = new int[st.size]; //Stack using an array.
	st.top = -1;
	
	return 0;
}
#Push funcution:
I/P:
void push(stack *st,int x){
	
	if(st->top==st->size-1){
		cout<<"Stack Overflow."
	}else{
		st->top++;  //This command lets us to iterate to the empty sapce of the stack.
	    st->s[st->top]=x;  //We are using '*s' pointer to traverse through and 'top' for accessing the indexes by using object pointer 'st'.
	}
}

#Pop function:
I/P:

int pop(stack *st){
	int x=-1;
	if(st->top==-1){
		cout<<"Stack Overflow";
	}else{
		st->s[st->top]=x;
		st->top--;
	}
	return x;
}

#Peek function:
I/P:
                                    
void peek(struct stack st,int pos){
	
	int x=-1;
	if(st.top - pos +1>0){
		cout<<"Invalid Position";
	}else{
		x=st.s[st.top - pos +1]; //This is a formula for finding out the index of the stack.
	}
	return x;
}

#Diplaying the stack:
I/P:
void Display(struct stack st){
    for(int i=top;i>=0;i--){
       cout<<st->s[i];
    }
}

----------------------------------------------------------------------------------
Stack Using Linked List: In this type we will start inserting elements from the last and to head.
# Push Function:
I/P:
struct Node{
  int data;
  Node *next;
};

struct stack{
  int size;
  stack *s;
};

void push(int x){
  Node *t= new Node;
  if(t===NULL){
    cout<<"Stack Overflow";
}else{
     t->data =x
     t->next = top;
     top=t;
     }
    }
    
 # Pop function:
 I/P:
 int pop(){
 Node *p;
 int x=-1;
 if(top==NULL){
   cout<<"Stack is empty.";
   }else{
     p=top;
     top=top->next;
     x=p->data;
     delete p;
    
   }
   return x;
 }
 
# Peek funcion:
I/P:

int peek (int pos){
  Node *p;
  int x=-1;
  for(int i=;i<pos-1;i++ && p!=0){
    p=p->next;
  }
  
  if(p!=NULL){
    return p->data;
  }else{
  return -1}
  
}
NOTE :- Stack operations using Linked List written in C++ Language:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
		Node *next;
};

class Stack{
	private:
		Node *top;
	public:
		Stack(){
			top == NULL;
		}
		void push(int x){
			Node *t;
			t= new Node;
			if(t==NULL){
				cout<<"Stack is empty";
			}else{
				 t->data =x;
				 t->next =top;
				 top =t;
			}
		}
		
		int pop(){
			int x=-1;
			if(top==NULL){
				cout<<"Stack is empty.";
			}else{
				x=top->data;
				Node *t = new Node;
				t=top;
				top=top->next;
				delete t;
				return x;
			}
		}
		void Display(){
			Node *p;
			while(p!=NULL){
				cout<<p->data;
				p=p->next;
			}
		}
};

int main(){
	Stack st;
	st.push(12);
	st.push(20);
	st.push(30);
	st.Display();
	return 0;
}

5. Queues :- Follows FIFO property.
# Using an array: 
I/P:
NOTE:- Following codes are written in C language.
struct queue{    //This is how a queue's structure should look like.
	int size;
	int front;
	int rear;
	int *Q;
};


int main(){
	
	struct queue q;    //Initializing a queue.
	cout<<"Enter the size of the queue:";
	cin>>q.size;
	
	q.Q = new queue;
	q.front=q.rear=-1;
	
	return 0;
}

# Enqueue function:
I/P:
void enqueue(queue *q,int x){
	if(q->rear==q->size-1){
		cout<<"Queue is full";
	}else{
		cout<<"Enter the value you want to enter:";
		cin>>x;
		q->rear++;
		q->Q[q->rear]=x;
		
	}
	
	
}
# Dequeue function:
I/P:
int dequeue(queue *q){
   int x=-1;
   if(q->front==q->rear){
      cout<<"Queue is empty";
   }else{
      q->front++;
      x=q->Q[q->rear];
   }
   return x;
}
--------------------------------------------------------
Note: The code written below is written in C++ languge:
I/P:
#include<iostream>
using namespace std;

class queue{
	private:
		int size;
		int front;
		int rear;
		int *Q;
		
	
	public:
		queue(){
			front = rear =-1;
			size =10;
			Q = new int[size];
			
		}
		queue(int size){
			front = rear =-1;
			this->size=size;
			Q = new int[this->size];
		}
		
		void enqueue(int x){
			if(rear == size-1){
				cout<<"Queue is full";
			}else{
				
				rear++;
				Q[rear]=x;
			}
		}
		int dequeue(){
			int x=-1;
			if(front == rear ){
				cout<<"Queue is empty";
				
			}else{
				x=Q[front+1];
				front++;
			}
			return x;
		}
		
		void Display(){
			for(int i=front+1;i<=rear;i++){
				cout<<Q[i];
			}
		}
};


int main(){
	
		queue q(3);
		q.enqueue(10);
		q.enqueue(23);
		q.enqueue(45);
		q.Display();
		
	
	return 0;
}
                  Circular Queue (Differences can be spot in enqueue,dequeue and the display function):
I/P:
#include<iostream>
using namespace std;

class queue{
	private:
		int size;
		int front;
		int rear;
		int *Q;
		
	
	public:
		queue(){
			front = rear =-1;
			size =10;
			Q = new int[size];
			
		}
		queue(int size){
			front = rear =-1;
			this->size=size;
			Q = new int[this->size];
		}
		
		void enqueue(int x){
			if((rear+1)% this->size==front){
				cout<<"Queue is full";
			}else{
				
				rear = (rear+1) % this->size;
				Q[rear]=x;
			}
		}
		int dequeue(){
			int x=-1;
			if(front == rear ){
				cout<<"Queue is empty";
				
			}else{
				front = (front+1)% this->size;
				x=Q[front+1];
				
			}
			return x;
		}
		
		void Display(){
			
			int i=front+1;
			do{
			    cout<<Q[i];
			    i=(i+1)% this->size;
			}while(i!=(rear+1)% this->size);
			
		}
};


int main(){
	
		queue q(3);
		
		q.enqueue(10);
		q.enqueue(23);
		q.enqueue(45);
		q.Display();
		
	
	return 0;
}

## Queue using Linked List:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		int data;
    	Node *next;
};

class queue{
	private:
		Node *front;
		Node *rear;
	
	public:
		queue(){
			front = NULL;
			rear = NULL;
		}
		~queue(){
			Node *p;
			while(front){
				p=front;
				delete p;
				front = front->next;
			}
		}
		
		void enqueue(int x){
			
			Node *t = new Node;
			if(t==NULL){
				cout<<"Queue is full.";
			}else{
				t->data=x;
				t->next=NULL;
				if(front==NULL){
					front =rear =t;
				}else{
					rear =t;
					rear->next=NULL;
				}
			}
			
		int dequeue(){
				int x=-1;
				Node *p;
				if(front==NULL){
					cout<<"Queue is empty.";
				}else{
					p=front;
					x=p->data;
					front=front->next;
					delete p;
				}
			}
			
		void Display(){
				Node *p=front;
				
				while(p){
					cout<<p->data;
					p=p->next;
				
				}
			}
			
		
};


int main(){
	
	queue q;
	q.enqueue(12);
	q.enqueue(23);
	q.enqueue(24);
	q.Display();
	
	return 0;
}

6. Trees:-

Using Linked List-
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		Node *rchild;
};

class Queue{
	private:
		int size;
		int front;
		int rear;
		Node **Q;
		
	public:
		Queue(int size){
			this->size=size;
			front=rear=-1;
			Q = new Node* [size];
		}
		
		~Queue(){
			delete []Q;
		}
		
		bool isEmpty(){
			if(front==rear){
				return true;
			}else{
				return false;
			}
		}
		
		bool isFull(){
			if(rear==size-1){
				return true;
			}else{
				return false;
			}
		}
		
		void enqueue(Node *x){
			if(isFull()){
				cout<<"Queue overflow.";
			}else{
				rear++;
				Q[rear]=x;
			}
			
		}
		
		Node *dequeue(){
			
			Node *x = NULL;
			if(isEmpty()){
				cout<<"Queue is Empty.";
			}else{
				front++;
				x=Q[front];
			}
			return x;
		}
};

Node *root = new Node;

void Treecreate(){
	Node *p;
	Node *t;
	Queue q(10);
	int x;
	cout<<"Enter the root of the tree:";
	cin>>x;
	root->data =x;
	root->lchild = NULL;
	root->rchild=NULL;
	q.enqueue(root);
	while(!q.isEmpty()){
		p=q.dequeue();
		
		cout<<"Enter the value of the left child of  "<<p->data<<":";
		cin>>x;
		if(x!=-1){
			t =new Node;
			t->data=x;
			t->lchild=NULL;
			t->rchild=NULL;
			p->lchild=t;
			q.enqueue(t);
		}
		cout<<"Enter the value of right child of "<<p->data<<":";
		cin>>x;
		if(x!=-1){
			t= new Node;
			t->data=x;
			t->lchild=NULL;
			t->rchild=NULL;
			p->rchild=t;
			q.enqueue(t);
		}
	}
	
	
}

void preorder(Node *p){
	if(p){
		cout<<p->data<<",";
		preorder(p->lchild);
		preorder(p->rchild);
	}
}

void inorder(Node *p){
	if(p){
		inorder(p->lchild);
		cout<<p->data<<",";
		inorder(p->rchild);
	}
}

void postorder(Node *p){
	if(p){
		preorder(p->lchild);
		preorder(p->rchild);
		cout<<p->data<<",";
	}
}

int main(){
	Treecreate();
	preorder(root);
	cout<<endl;
	
}

## Counting number of nodes in a Binary tree:-
I/P:
int count(Node *p){  //This funcntion is used to count the number of nodes in a tree.
    int x,y;
    if(p!=NULL){
       	x=count(p->lchild);
	y=count(p->rchild);
	return x+y+1;
    }
    return 0;
}

int count(Node *p){   //This function will count number of nodes with degree 2 or nodes with two children.
   int x,y;
   if(p!=NULL){
      x=count(p->lchild);
      y=count(p->rchild);
      if(p->lchild && p->rchild){
          return x+y+1;
	  }else{
	     return x+y;
	  }
	  return 0;
   }
}


## Binary Search Tree:-
(a) Searching -
I/P: 
int Rsearch(Node *t,int key){
    cout<<"Enter the key you want to search:";;
    cin>>key;
    if(t==NULL){
      return t;    //This function uses recursive call to search
    }else(
       if(key==t->data){
          reutn t;
       }else if(key>p->data){
          return Rsearch(p->lchild,key);
       }else{
          return Rsearch(p->rchild,key);
       }
    )
}

/* This funcction uses search iteratively.*/
Node *search(Node *t,int key){
   cout<<"Enter the key value you want to search:";
   cin>>key;
   while(t!=NULL){
     if(key==t->data){
        return t;
     }else if(key<t->data){
        t=t->lchild;
     }else{
        t=t->rchild;
     }
     
   }
   return NULL;
   
## Inserting Node in a Binary search tree:
I/P:
void insert(Node *t,int key){
  cout<<"Enter the key you want to insert:";
  cin>>key;
  
  Node *r=NULL;*t;
  while(t!=NULL){
     r=t;
     if(key==t->data){
        return;
     }else if(key<t->data){ 
        t=t->lchild;
     
     }else{
        t=t->rchild;
     }
    }
     Node *p = new Node;
     p->lchild = p->rchild = NULL;
     p->data = key;
     if(p->data<r->data){
        r->lchild = p;
     }else{
        r->rchild = p;
     }
  }
  /* This Insert function is written in recursive form form.
Node *insert(Node *p,int key){
   Node *t;
   if(p=NULL){
      t= new Node;
      t->data =key;
      t->lchild = t->rchild = NULL;
      return t;
   }
   if(key<p->data){
     p->lchild = insert(p->lchild,key);
   }else{
     p->rchild = insert(p->rchiild,key);
   }

}


int main(){ 
   Node *root =NULL;
   root = insert(root,30); //Thos statement helps in cretaing the first root node of a binary search tree.
   /*These steps now create new children nodes of the root node.*/
   insert(root,23);
   insert(root,10);
   return 0;



}
NOTE : The code below mentions the creation and search of the Binary Search tree:
I/P:
#include<iostream>
using namespace std;

class Node{
	public:
		Node *lchild;
		int data;
		Node *rchild;
};

class Binarytree{
	private:
		Node *root;
	public:
		Binarytree(){
			root =NULL;
		}
		Node *getRoot(){
			return root;
		}
		
		void insert(int key){
			Node *p,*r;
			Node *t=root;
			//If root is empty'
			if(root==NULL){
				p=new Node;
				p->data=key;
				p->lchild=NULL;
				p->rchild=NULL;
				root=p;
				return;
			}
			while(t!=NULL){
				r=t;
				if(key<t->data){
					t=t->lchild;
				}else if(key>t->data){
					t=t->rchild;
				}else{
					return;
				}
			}
			//Now t points at NULL and r at the insert position.
			p= new Node;
			p->data=key;
			p->lchild=NULL;
			p->rchild=NULL;
			
			if(key<r->data){
				r->lchild=p;
			}else{
				r->rchild=p;
			}
			
			
			
		}
		Node *search(int key){
			Node *t = root;
			while(t!=NULL){
				if(key==t->data){
					return t;
				}else if(key<t->data){
					t=t->lchild;
				}else{
					t=t->rchild;
				}
			}
			return NULL;
		}
		void inorder(Node *p){
			if(p){
				inorder(p->lchild);
				cout<<p->data;
				inorder(p->rchild);
			}
		}
		
};


int main(){
	class Binarytree bst;
	bst.insert(90);
	bst.insert(79);
	bst.insert(60);
	
	bst.inorder(bst.getRoot());
	cout<<endl;
	
	Node *temp = bst.search(60);
	if(temp!=NULL){
		cout<<"Element found:"<<temp->data<<endl;
	}else{
		cout<<"Element not found.";
	}
	
	return 0;
}



