                       ----------This contains codes of Data Structures written C++ ----------------------
                    
  1. Binary search :
  I/P:
#include<iostream>
using namwspace std;
/* It is using iterators.*/

int Bibary_Search(struct Array arr,int key){//Here, we have used struct Array and object arr.
	int l=0;
	int h = arr.length-1; //Here, .length is a class function means ut can only be applied on members of structure and classes.
	
	while(l<=h){
		int mid = (l+h)/2;
		
		if(key==arr.A[mid]){
			return mid;
		}else if(key<arr.A[mid]){
			h = mid-1;
			   
		}else{
			l= mid+1;
		}
		

	}
	return -1;
}

int main(){
	struct Array arr={{2,3,5,6},20,23}; //Here, Array is the name of the struct and arr is the name of the object.
	
    cout<<Binary_Search(arr,5); //It will only show the index number if the found element.
	
	return 0;
	
}
 
------------------------------------------------------------------------------
/*Using recursive function.*/ 
int Rbinary_Search(int A[],int l,int h, int key){
	int mid;
	if(l<=h){
		mid = (l+h)/2;
		if(key==A[mid]){
			return mid;
		}else if(key<A[mid]){
			return Rbinary_Search(A,l,mid-1,key)
		}else{
			return Rbinary_Search(A,mid+1,h,key)
		}
	}
	return -1;
}
int main(){
	int A[3]= {1,2,3};
	Rbinary_Search(A,0,2,2);
	return 0;
}



2. Revesing an array :

I/P:   
/*This method uses an another array.
int reverse(int A[]){
  int i,j;
  int B[];
  }
  for(i=A.length-1,j=0;i>=0,j>=A[].length-1;i--,j++){
      B[j] = A[i];
  }
  
  for(i=0,j=0;i>=B.length-1,j>=B.length-1;i++,j++){
      A[i] = B[j];
      }
--------------------------------------------------------------------------------
/*This one uses swapping of the elements within the array.
int main(){
   int i,j;
   for(i=0,j=A.length-1;i>=A.length-1,j=0;i++,j--){
      int temp = A[i];
      A[i] = A[j];
      A[j] = temp;
   }
}

3. Linked List:
# Creating a LL(using an array)-
I/P:
struct Node{
 int data;    //This is how a struct Node looks like but we can also use class instead of struct.
 struct Node *next; //This points to the next Node(Hence,next is the name of the pointer.)
}first;

void create(int A[],int n){
  int i;
  struct Node *t,*last;   //This wil be the first node of our linked list.
  first = new Node;
  first->data = A[0];
  first->next=NULL;
  last = first;
        
  for(i=1;i<n;i++){  //This is for the following nodes.
   t =new Node;
   t->data =A[i];
   t->next =NULL;
   last->next =t;
   last =t;
   
   
                  }

}

void display(struct Node *p){
                              //Dispalying the elements of the linked list.
  while(p!=NULL){
  cout<<p->data;
  p=p->next;
   }
}

int main(){
 int A[5] ={1,2,3,4,5}
 create(A,5);
 display(first);
 return 0;
 }
# Inserting An element in the LL:
 (i)Before the first Node:-
    I/P:
         Node *t = new Node;
	 t->data = 21;
	 t->next = first;  //Here, '*first' is the global declared pointer used as head fir the linked list.
	 first = t;
(ii)At nth position:- 
    I/P:We actually insert the node at (n-1) position,
          Node *t = new Node;
	  p=first;  //This is to enter the begining of the linked list.
	  for(i=0;i<pos-1;i++){  //This is to tranverse the pinter p to the desired position.
	      p=p->next;
	  }
	  t->next = p->next;  //This is the address of the next Node saved in the inserted one.
	  p->next =t;  //This is the address of the inserted in it's predecessor.
	  
                         Types of Linked List:
(a) Circular Linked List: In this type of linked list the lat node has the address to the first or head node.

I/P:
#include<iostream>
using namespace std;

class Node(){
	public:
		int data;
		Node *next;
};

class LinkedList(){
	
	private:
		LinkedList(){
			Node *head;
		}
	
	public:
		LinkedList(){
			Node *head =NUll;
		}
		LinkedList(int A[],int n){
			Node *t,*last;
			head= new Node;
			head->data = A[0];
			head->next=head;
			last=head;
			
			for(int i=1;i<n;i++){
				Node *t,*last;
				t=new Node;
				t->data=A[i];
				t->next=last->next;
				last->next=t;
				last=t;
				
				
			}
			
		}
		
		void Display(Node *p){
			Node *p;
			p=head;
			do{
				cout<<p->data;
				p=p->next;
			}while(p!=head);
		}
};
	  
      
