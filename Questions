Here, question link will be provided and the required code will be given

Question 1 : https://www.codingninjas.com/codestudio/problems/first-and-last-position-of-an-element-in-sorted-array_1082549

Solution:-
   LeftOccur/FirstOccur function
   
int LeftOccur(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int ans=-1;
    int mid=start+((end-start)/2);
    while(start<=end){
        if(arr[mid]==key){
            ans=mid;
            end=mid-1;
        
        }else if(key>arr[mid]){
            start=mid+1;
        }else if(key<arr[mid]){
            end=mid-1;
        }
        mid=start=((end-start)/2);
    }
    return -1;
    
    RightOccur/LastOccur function:-
 
int RightOccur(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int ans=-1;
    int mid=start+((end-start)/2);
    while(start<=end){
        if(arr[mid]==key){
            ans=mid;
            start=mid+1;
        
        }else if(key>arr[mid]){
            start=mid+1;
        }else if(key<arr[mid]){
            end=mid-1;
        }
        mid=start=((end-start)/2);
    }
    return -1;
    
 Note: If the total occurences is asked then,
 
      Total No. Of occurences = (LastOccur - FirstOccur) + 1
---------------------------------------------------------------------------------------------
Question 2:- https://leetcode.com/problems/peak-index-in-a-mountain-array/
Solution:                                                            2 
                                                                    /  \
int PeakIndex(int arr[],int size){                                 1    2                             Here, 2 is the Peak(Largest Number). 
    int s=0;                                                      /      \                      LeftSide Depiction: Array[i]<Array[i+1].....
    int e=size-1;                                                0        1                      RightSide Depiction:  Array[i]>Array[i+1].....
    int mid=s+(e-s)/2;                                          Mountain Array {0,1,2,1,0}        Peak Depiction:     ......<Array[i-1]<Array[i]>Array[i-1]>....
                                                                                  
    while(s<e){    
        if(arr[mid]<arr[mid+1]){
            s=mid+1;
        }else{
            e=mid;  // combined both RightSide and Peak Case. Hence, cannot use e=mid-1.
        }
        mid=s+(e-s)/2;
    }
    return s;
}
---------------------------------------------------------------------------
Quetion 3: Finding the Pivot Element.
 Pivot element are found in sorted and rotated arrays.
 Example:
         Array A[5]={1,3,8,10,17} //Sorted Array
         Array B[5]={3,8,10,17,1} //Sorted & Roatated(4 times) Array
         // An array could be rotated n times.
         
         Pivot Element(minimum) in B is = 1.
         
Solution:
   int getPivot(int arr[],int size){
    int s=0;
    int e=size-1;
    int mid=s+(e-s)/2;
    while(s<e){
        if(arr[mid]>=arr[0]){  
            s=mid+1;
        }else{
            e=mid;
        }
        mid=s+(e-s)/2;
    }
    return s;
}
----------------------------------------------------------
Question 4 :- https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/
Solution: 
   class Solution {
public:
    int getPivot(vector<int>& arr,int size){
    int s=0;
    int e=arr.size()-1;
    int mid=s+(e-s)/2;
    while(s<e){
        if(arr[mid]>=arr[0]){
            s=mid+1;
        }else{
            e=mid;
        }
        mid=s+(e-s)/2;
    }
    return s;
}
    int BinarySearch(vector<int>& arr,int s,int e,int key){
        int start=s;
        int end=s;
        int mid=start+(end-start)/2;
        while(start<=end){
            if(arr[mid]==key){
                return mid;
            }else if(key>arr[mid]){
                start=mid+1;
            }else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return  -1;
    }
    
    
    int search(vector<int>& arr,int k){
        int pivot=getPivot(arr,arr.size());
        if(k>=arr[pivot] && k<=arr[arr.size()-1]){
            return BinarySearch(arr,pivot,arr.size()-1,k);
        }else{
            return BinarySearch(arr,0,pivot,k);
        }
        
    }
};
--------------------------------------------------
Question 5: https://leetcode.com/problems/sqrtx/submissions/
Solution:-
   long long int BinarySearch(int num){
    int s=0;
    int e=num;
    long long int ans=-1;
    long long int mid=s+(e-s)/2;
    while(s<=e){
        long long int square=mid*mid;
        if(square==num){
            return mid;
        }
        if(square<num){
            ans=mid;
            s=mid+1;
        }else{
            e=mid-1;
        }
        mid=s+(e-s)/2;
        
    }
    return ans;
    }
 
To findout the sqrt precise upto n decimal placed ww will add an extra function in the above code,
double morePrecisoin(int n,int precision,int tempsol){
    double factor=1;
    double ans = tempsol; //The integer part of square root of n
    for(int i=0;i<=precison;i++){ 
        factor=factor/10;
        for(double j=ans;j*j<n;j=j+factor){
            ans=j;
        }
    }
   return ans;
}
----------------------------------------------------------------------
Question 5: https://leetcode.com/problems/reverse-string/submissions/
Solution :- 
   class Solution {
public:
    void reverseString(vector<char>& s) {
        int st=0;
        int e=s.size()-1;
        while(st<e){
            swap(s[st++],s[e--]);
        }
        
    }
};
---------------------------------------------------
Question 6: Check if a string is a palindrome(not case sensitive).
Solution:
char toLowerCase(char c){  //'Not case sensitive' means we will have to convert all the strings to lowercase to compare the characters of the string.
    if((c>='a'&&c<='z') || (c>='0' && c<='9') ){
        return c;
    }else{
        c=c+32;
    }
}
bool palindrome(char c[],int n){
    int s=0;
    int e=n-1;
    while(s>=e){
        if(toLowerCase(c[s])!=toLowerCase(c[e])){
            return 0;
        }else{
            s++;
            e--;

        }

    }
    return 1;
}
----------------------------------------------
Question 7: https://leetcode.com/problems/valid-palindrome/
Solution: 
class Solution{
private:
    bool valid(char c){
        if((c>='a'&&c<='z') ||   (c>='A'&&c<='Z') || (c>='0'&&c<='9')   ){
            return 1;
        }
        return 0;
    }
    char toLowerCase(char c){  
        if((c>='a'&&c<='z') || (c>='0' && c<='9') ){
            return c;
        }else{
            c=c+32;
            return c;
        }
    }
    bool palindrome(string a){
        int s=0;
        int e=a.length()-1;
        while(s>=e){
            if(a[s]!=a[e]){
                return 0;
            }else{
                s++;
                e--;

            }

        }
        return 1;
    }
public:
    bool isPalindrome(string s) {
        //Removing useless characters
        string temp="";
        
        for(int i=0;i<s.length();i++ ){
            if(valid(s[i])){
                temp.push_back(s[i]);
            }
        }
            
        //cnverting to lower case
        for(int i=0;i<s.length();i++){
            temp[i]=toLowerCase(s[i]);
        }
            
        return palindrome(s);
    }
             
    
};
