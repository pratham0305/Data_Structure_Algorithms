

Question 1 : https://www.codingninjas.com/codestudio/problems/first-and-last-position-of-an-element-in-sorted-array_1082549

Solution:-
   LeftOccur/FirstOccur function
   
int LeftOccur(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int ans=-1;
    int mid=start+((end-start)/2);
    while(start<=end){
        if(arr[mid]==key){
            ans=mid;
            end=mid-1;
        
        }else if(key>arr[mid]){
            start=mid+1;
        }else if(key<arr[mid]){
            end=mid-1;
        }
        mid=start=((end-start)/2);
    }
    return -1;
    
    RightOccur/LastOccur function:-
 
int RightOccur(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int ans=-1;
    int mid=start+((end-start)/2);
    while(start<=end){
        if(arr[mid]==key){
            ans=mid;
            start=mid+1;
        
        }else if(key>arr[mid]){
            start=mid+1;
        }else if(key<arr[mid]){
            end=mid-1;
        }
        mid=start=((end-start)/2);
    }
    return -1;
    
 Note: If the total occurences is asked then,
 
      Total No. Of occurences = (LastOccur - FirstOccur) + 1
---------------------------------------------------------------------------------------------
Question 2:- https://leetcode.com/problems/peak-index-in-a-mountain-array/
Solution:                                                            2 
                                                                    /  \
int PeakIndex(int arr[],int size){                                 1    2                             Here, 2 is the Peak(Largest Number). 
    int s=0;                                                      /      \                      LeftSide Depiction: Array[i]<Array[i+1].....
    int e=size-1;                                                0        1                      RightSide Depiction:  Array[i]>Array[i+1].....
    int mid=s+(e-s)/2;                                          Mountain Array {0,1,2,1,0}        Peak Depiction:     ......<Array[i-1]<Array[i]>Array[i-1]>....
                                                                                  
    while(s<e){    
        if(arr[mid]<arr[mid+1]){
            s=mid+1;
        }else{
            e=mid;  // combined both RightSide and Peak Case. Hence, cannot use e=mid-1.
        }
        mid=s+(e-s)/2;
    }
    return s;
}
---------------------------------------------------------------------------
Quetion 3: Finding the Pivot Element.
 Pivot element are found in sorted and rotated arrays.
 Example:
         Array A[5]={1,3,8,10,17} //Sorted Array
         Array B[5]={3,8,10,17,1} //Sorted & Roatated(4 times) Array
         // An array could be rotated n times.
         
         Pivot Element(minimum) in B is = 1.
         
Solution:
   int getPivot(int arr[],int size){
    int s=0;
    int e=size-1;
    int mid=s+(e-s)/2;
    while(s<e){
        if(arr[mid]>=arr[0]){  
            s=mid+1;
        }else{
            e=mid;
        }
        mid=s+(e-s)/2;
    }
    return s;
}
----------------------------------------------------------
Question 4 :- https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/
Solution: 
   class Solution {
public:
    int getPivot(vector<int>& arr,int size){
    int s=0;
    int e=arr.size()-1;
    int mid=s+(e-s)/2;
    while(s<e){
        if(arr[mid]>=arr[0]){
            s=mid+1;
        }else{
            e=mid;
        }
        mid=s+(e-s)/2;
    }
    return s;
}
    int BinarySearch(vector<int>& arr,int s,int e,int key){
        int start=s;
        int end=s;
        int mid=start+(end-start)/2;
        while(start<=end){
            if(arr[mid]==key){
                return mid;
            }else if(key>arr[mid]){
                start=mid+1;
            }else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return  -1;
    }
    
    
    int search(vector<int>& arr,int k){
        int pivot=getPivot(arr,arr.size());
        if(k>=arr[pivot] && k<=arr[arr.size()-1]){
            return BinarySearch(arr,pivot,arr.size()-1,k);
        }else{
            return BinarySearch(arr,0,pivot,k);
        }
        
    }
};
--------------------------------------------------
Question 5: https://leetcode.com/problems/sqrtx/submissions/
Solution:-
   long long int BinarySearch(int num){
    int s=0;
    int e=num;
    long long int ans=-1;
    long long int mid=s+(e-s)/2;
    while(s<=e){
        long long int square=mid*mid;
        if(square==num){
            return mid;
        }
        if(square<num){
            ans=mid;
            s=mid+1;
        }else{
            e=mid-1;
        }
        mid=s+(e-s)/2;
        
    }
    return ans;
    }
 
To findout the sqrt precise upto n decimal placed ww will add an extra function in the above code,
double morePrecisoin(int n,int precision,int tempsol){
    double factor=1;
    double ans = tempsol; //The integer part of square root of n
    for(int i=0;i<=precison;i++){ 
        factor=factor/10;
        for(double j=ans;j*j<n;j=j+factor){
            ans=j;
        }
    }
   return ans;
}
----------------------------------------------------------------------
Question 5: https://leetcode.com/problems/reverse-string/submissions/
Solution :- 
   class Solution {
public:
    void reverseString(vector<char>& s) {
        int st=0;
        int e=s.size()-1;
        while(st<e){
            swap(s[st++],s[e--]);
        }
        
    }
};
---------------------------------------------------
Question 6: Check if a string is a palindrome(not case sensitive).
Solution:
char toLowerCase(char c){  //'Not case sensitive' means we will have to convert all the strings to lowercase to compare the characters of the string.
    if((c>='a'&&c<='z') || (c>='0' && c<='9') ){
        return c;
    }else{
        c=c+32;
    }
}
bool palindrome(char c[],int n){
    int s=0;
    int e=n-1;
    while(s>=e){
        if(toLowerCase(c[s])!=toLowerCase(c[e])){
            return 0;
        }else{
            s++;
            e--;

        }

    }
    return 1;
}
----------------------------------------------
Question 7: https://leetcode.com/problems/valid-palindrome/
Solution: 
class Solution{
private:
    bool valid(char c){
        if((c>='a'&&c<='z') ||   (c>='A'&&c<='Z') || (c>='0'&&c<='9')   ){
            return 1;
        }
        return 0;
    }
    char toLowerCase(char c){  
        if((c>='a'&&c<='z') || (c>='0' && c<='9') ){
            return c;
        }else{
            c=c+32;
            return c;
        }
    }
    bool palindrome(string a){
        int s=0;
        int e=a.length()-1;
        while(s>=e){
            if(a[s]!=a[e]){
                return 0;
            }else{
                s++;
                e--;

            }

        }
        return 1;
    }
public:
    bool isPalindrome(string s) {
        //Removing useless characters
        string temp="";
        
        for(int i=0;i<s.length();i++ ){
            if(valid(s[i])){
                temp.push_back(s[i]);
            }
        }
            
        //cnverting to lower case
        for(int i=0;i<s.length();i++){
            temp[i]=toLowerCase(s[i]);
        }
            
        return palindrome(s);
    }
             
    
};
------------------------------------------------------------
Question 8: maximum occurence of a character in a string.
solution:
char maxOccurence(string s){
    int arra[26]={0};
    for(int i=0;i<s.length();i++){
        int position=0;
        //for lower case characters
        if(s[i]>='a' && s[i]<='z'){
            position = s[i]-'a';
        }else{//for upper case characters
            position=s[i]-'A';
        }
        arra[position]++;
    }

    int max=-1,ans=0;
    for(int i=0;i<26;i++){
        if(max<arra[i]){
            ans=i;
            max=arra[i];
        }
    }
    char finalanswer='a'+ans;
    return finalanswer;

}
int main(){
   
    string s;
    cin>>s;
    cout<<maxOccurence(s)<<endl;
    
    return 0;
}
-------------------------------------------
Question 8: Repalce all the witspaces in a string with "@u".
Solution: 
string replacSpace(string &str){
    string temp="";
    for(int i=0;i<str.length();i++){
        if(str[i]==' '){
            temp.push_back("@");
            temp.push_back("u");
        }else{
            temp.push_back(str[i]);
        }
    }

    return temp;
}
---------------------------------------------------------------
Questio 9: https://leetcode.com/problems/remove-all-occurrences-of-a-substring/submissions/
Solution:
class Solution {
public:
    string removeOccurrences(string s, string part) {
        while(s.length()!=0 && s.find(part)<s.length()){
            s.erase(s.find(part),part.length());
        }
        return s;
    }
};
-----------------------------------------------
Question 10: https://leetcode.com/problems/permutation-in-string/
Solution: 
class Solution {
private:
    bool checkEqual(int a[26], int b[26]){
        for(int i=0;i<26;i++){
            if(a[i]!=b[i]){
                return 0;
            }
        }
        return 1;
    }
public:
    bool checkInclusion(string s1, string s2) {
        int count1[26]={0};
        //creating count array for s1
        for(int i=0;i<s1.length();i++){
            int index=s1[i]-'a';
            count1[index]++;
        }
        
        //creating count for first window of s2
        int i=0;
        int windowSize=s1.size();
    
        int count2[26]={0};
        while(i<windowSize){
            int index=s2[i]-'a';
            count2[index]++;
            i++;
        }
        //checking for first window
        if(checkEqual(count1,count2)){
            return 1;
        }
        //For next window
        while(i<s2.length()){
            char newChar=s2[i];
            int index=newChar-'a';
            count2[index]++;
            
            char oldChar=  s2[i-windowSize];
            index =oldChar-'a';
            count2[index]--;
            i++;
            if(checkEqual(count1,count2)){
                return 1;
            }
            
            }
        return 0;
        
    }
};
-------------------------------------------------------------------
Question 11: Print a 2D Array or mattrix in the form of Wave Print,

               Matrix :  1 2 3
                         4 5 6
                         8 9 10 
                         
                Wave Print: 1 9 3
                            4 5 6 
                            8 2 10
Solution: Here, we have used a Vector.
vector<int> wavePrint(vector<vector<int>arr,int r,int c){
    vector<int>ans;
    for(int col=0;col<c;col++){
        if(col&1){
            //odd index ->bottom to top
            for(int row=r-1;row>=0;row--){
                //cout<<arr[row][col]       
                ans.push_back(arr[row][col]);
            }


        }else{
            //even index ->top to bottom
            for(int row=0;row<n;row++){
            
                //cout<<arr[row][col]
                ans.push_back(arr[row][col]);
            }


        }


    }
    return ans;  
}
----------------------------------------------------------------------------------
Question 12: https://leetcode.com/problems/search-a-2d-matrix/submissions/
Solution: 
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row=matrix.size();
        int col=matrix[0].size();
        
        int start=0;
        int end=(row*col)-1;
        
        int mid = start+(end-start)/2;
        while(start<=end){
            int element=matrix[mid/col][mid%col];
            if(element==target){
                return 1;
            }
            if(element<target){
                start=mid+1;
            }else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
            
        }
        return 0;
        
    }
};

-----------------------------------------------------------
Book Allocation Problem
Solution:
bool isPossible(vector<int>arr,int n,int m,int mid){
    int studentCount=1;
    int pageSum=0;

    for(int i=0;i<n;i++){
        if((pageSum+arr[i]) <= mid ){
            pageSum+=arr[i];
        }else{
            studentCount++;
            if(studentCount>m || arr[i] > mid){
                return false;

            }
            pageSum=0;
            pageSum=arr[i];
        }
    }
    return true;
}
int allocation(vector<int> arr,int n,int m){
    int s=0;
    int sum=0;

    for(int i=0;i<n;i++){
        sum+=arr[i];
    }

    int e=sum;
    int ans=-1;
    int mid=s+(e-s)/2;

    while(s<=e){
        if(isPossible(arr,n,m,mid)){
            ans=mid;
            e=mid-1;
        }else{
            s=mid+1;
        }
        mid=s+(e-s)/2;

    }
    return ans;
}
------------------------------------
Painter Partition Problem
Solution: 
bool ifPossible(vector<int>arr,int k, int mid){
    int PaintingPartSum=0;
    int painterCount=1;

    for(int i=0;i<arr.size();i++){
        if((PaintingPartSum+=arr[i]) < mid){
            PaintingPartSum+=arr[i];
        }else{
            painterCount++;
            if(painterCount>k || arr[i]>mid){
                return false;
            }
            PaintingPartSum=0;
            PaintingPartSum=arr[i];
        }
    }
    return true;

}

int FindMinimumTime(vector<int> arr,int k){
    int s=0;
    int sum=0;
    for(int i=0;i<arr.size();i++){
        sum+=arr[i];
    }
    int e=sum;
    int mid=s+(e-s)/2;
    int ans=-1;

    while(s<=e){
        if(isPossible(arr,k,mid)){
            ans=mid;
            e=mid-1;
        }else{
            s=mid+1;
        }
        mid=s+(e-s)/2;
    }
    return ans;
}
------------------------------------------
Aggressive Cow Problem
Solution:
bool ifPossible(vecotr<int>& arr,int k,int mid){
    int cowCount=1;
    int lastPos=arr[0]; 

    for(int i=0;i<arr.size();i++){
        if((arr[i]-lastPos) >= mid){
            cowCount++;
            if(cowCount==k){
                return true;

            }
            lastPos=arr[i];
        }
    }
    return false;
}

int aggressiveCows(vecotr<int>& arr,int k){
    int s=0;
    int maxi=-1;
//We have to sort the given array, so as to properly calculate dist. b/w stalls
    sort(v.begin(),v.end());

    for(int i=0;i<arr.size();i++){
        maxi=max(maxi,arr[i]);
    }
    int ans=-1;
    int e=maxi;
    int mid=s+(e-s)/2;
    while(s<=e){
        if(ifPossible(arr,k,mid)){
            ans=mid;
            s=mid+1;//we need to keep cows at max distance
        }else{
            e=mid-1;
        }
        mid=s+(e-s)/2;
    }
    return ans;
}
------------------------------------------------
Question 13:https://leetcode.com/problems/move-zeroes/submissions/

Solution : 
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int nonZero=0;
        for(int j=0; j<nums.size();j++){
            if(nums[j]!=0){
                swap(nums[j],nums[nonZero]);
                nonZero++;
            }
        }
        
    }
};
-----------------------------------------------------------------------
Question 14: https://leetcode.com/problems/rotate-array/submissions/
Solution:
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        vector<int> temp(nums.size());
        
        
        for(int i=0;i<nums.size();i++){
            temp[(i+k)%nums.size()]=nums[i];    
        }
        nums=temp;
        
    }
};

            
                     
