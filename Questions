Here, question link will be provided and the required code will be given

Question 1 : https://www.codingninjas.com/codestudio/problems/first-and-last-position-of-an-element-in-sorted-array_1082549

Solution:-
   LeftOccur/FirstOccur function
   
int LeftOccur(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int ans=-1;
    int mid=start+((end-start)/2);
    while(start<=end){
        if(arr[mid]==key){
            ans=mid;
            end=mid-1;
        
        }else if(key>arr[mid]){
            start=mid+1;
        }else if(key<arr[mid]){
            end=mid-1;
        }
        mid=start=((end-start)/2);
    }
    return -1;
    
    RightOccur/LastOccur function:-
 
int RightOccur(int arr[],int size,int key){
    int start=0;
    int end=size-1;
    int ans=-1;
    int mid=start+((end-start)/2);
    while(start<=end){
        if(arr[mid]==key){
            ans=mid;
            start=mid+1;
        
        }else if(key>arr[mid]){
            start=mid+1;
        }else if(key<arr[mid]){
            end=mid-1;
        }
        mid=start=((end-start)/2);
    }
    return -1;
    
 Note: If the total occurences is asked then,
 
      Total No. Of occurences = (LastOccur - FirstOccur) + 1
---------------------------------------------------------------------------------------------
Question 2:- https://leetcode.com/problems/peak-index-in-a-mountain-array/
Solution:                                                            2 
                                                                    /  \
int PeakIndex(int arr[],int size){                                 1    2                             Here, 2 is the Peak(Largest Number). 
    int s=0;                                                      /      \                      LeftSide Depiction: Array[i]<Array[i+1].....
    int e=size-1;                                                0        1                      RightSide Depiction:  Array[i]>Array[i+1].....
    int mid=s+(e-s)/2;                                          Mountain Array {0,1,2,1,0}        Peak Depiction:     ......<Array[i-1]<Array[i]>Array[i-1]>....
                                                                                  
    while(s<e){    
        if(arr[mid]<arr[mid+1]){
            s=mid+1;
        }else{
            e=mid;  // combined both RightSide and Peak Case. Hence, cannot use e=mid-1.
        }
        mid=s+(e-s)/2;
    }
    return s;
}
---------------------------------------------------------------------------
Quetion 3: Finding the Pivot Element.
 Pivot element are found in sorted and rotated arrays.
 Example:
         Array A[5]={1,3,8,10,17} //Sorted Array
         Array B[5]={3,8,10,17,1} //Sorted & Roatated(4 times) Array
         // An array could be rotated n times.
         
         Pivot Element(minimum) in B is = 1.
         
Solution:
   int getPivot(int arr[],int size){
    int s=0;
    int e=size-1;
    int mid=s+(e-s)/2;
    while(s<e){
        if(arr[mid]>=arr[0]){  
            s=mid+1;
        }else{
            e=mid;
        }
        mid=s+(e-s)/2;
    }
    return s;
}
----------------------------------------------------------
Question 4 :- https://leetcode.com/problems/search-in-rotated-sorted-array/submissions/
Solution: 
   class Solution {
public:
    int getPivot(vector<int>& arr,int size){
    int s=0;
    int e=arr.size()-1;
    int mid=s+(e-s)/2;
    while(s<e){
        if(arr[mid]>=arr[0]){
            s=mid+1;
        }else{
            e=mid;
        }
        mid=s+(e-s)/2;
    }
    return s;
}
    int BinarySearch(vector<int>& arr,int s,int e,int key){
        int start=s;
        int end=s;
        int mid=start+(end-start)/2;
        while(start<=end){
            if(arr[mid]==key){
                return mid;
            }else if(key>arr[mid]){
                start=mid+1;
            }else{
                end=mid-1;
            }
            mid=start+(end-start)/2;
        }
        return  -1;
    }
    
    
    int search(vector<int>& arr,int k){
        int pivot=getPivot(arr,arr.size());
        if(k>=arr[pivot] && k<=arr[arr.size()-1]){
            return BinarySearch(arr,pivot,arr.size()-1,k);
        }else{
            return BinarySearch(arr,0,pivot,k);
        }
        
    }
};
--------------------------------------------------
Question 5: https://leetcode.com/problems/sqrtx/submissions/
Solution:-
   long long int BinarySearch(int num){
    int s=0;
    int e=num;
    long long int ans=-1;
    long long int mid=s+(e-s)/2;
    while(s<=e){
        long long int square=mid*mid;
        if(square==num){
            return mid;
        }
        if(square<num){
            ans=mid;
            s=mid+1;
        }else{
            e=mid-1;
        }
        mid=s+(e-s)/2;
        
    }
    return ans;
    }
 
To findout the sqrt precise upto n decimal placed ww will add an extra function in the above code,
double morePrecisoin(int n,int precision,int tempsol){
    double factor=1;
    double ans = tempsol; //The integer part of square root of n
    for(int i=0;i<=precison;i++){ 
        factor=factor/10;
        for(int j=ans;j*j<n;j=j+factor){
            ans=j;
        }
    }
   return ans;
}
